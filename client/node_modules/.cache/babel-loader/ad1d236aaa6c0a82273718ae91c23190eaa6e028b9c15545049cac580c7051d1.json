{"ast":null,"code":"\"use strict\";\n\nvar _objectDestructuringEmpty = require(\"/Users/glebch/workprojects/baumna/client/node_modules/@babel/runtime/helpers/objectDestructuringEmpty.js\").default;\nvar _objectSpread = require(\"/Users/glebch/workprojects/baumna/client/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientEncryption = void 0;\nexports.autoSelectSocketOptions = autoSelectSocketOptions;\nconst bson_1 = require(\"../bson\");\nconst deps_1 = require(\"../deps\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst cryptoCallbacks = require(\"./crypto_callbacks\");\nconst errors_1 = require(\"./errors\");\nconst index_1 = require(\"./providers/index\");\nconst state_machine_1 = require(\"./state_machine\");\n/**\n * @public\n * The public interface for explicit in-use encryption\n */\nclass ClientEncryption {\n  /** @internal */\n  static getMongoCrypt() {\n    const encryption = (0, deps_1.getMongoDBClientEncryption)();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n  /**\n   * Create a new encryption instance\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     local: {\n   *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     aws: {\n   *       accessKeyId: AWS_ACCESS_KEY,\n   *       secretAccessKey: AWS_SECRET_KEY\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  constructor(client, options) {\n    var _options$proxyOptions, _options$tlsOptions;\n    this._client = client;\n    this._proxyOptions = (_options$proxyOptions = options.proxyOptions) !== null && _options$proxyOptions !== void 0 ? _options$proxyOptions : {};\n    this._tlsOptions = (_options$tlsOptions = options.tlsOptions) !== null && _options$tlsOptions !== void 0 ? _options$tlsOptions : {};\n    this._kmsProviders = options.kmsProviders || {};\n    const {\n      timeoutMS\n    } = (0, utils_1.resolveTimeoutOptions)(client, options);\n    this._timeoutMS = timeoutMS;\n    if (options.keyVaultNamespace == null) {\n      throw new errors_1.MongoCryptInvalidArgumentError('Missing required option `keyVaultNamespace`');\n    }\n    const mongoCryptOptions = _objectSpread(_objectSpread({}, options), {}, {\n      cryptoCallbacks,\n      kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders\n    });\n    this._keyVaultNamespace = options.keyVaultNamespace;\n    this._keyVaultClient = options.keyVaultClient || client;\n    const MongoCrypt = ClientEncryption.getMongoCrypt();\n    this._mongoCrypt = new MongoCrypt(mongoCryptOptions);\n  }\n  /**\n   * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create a local key\n   * const dataKeyId = await clientEncryption.createDataKey('local');\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key with a keyAltName\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   },\n   *   keyAltNames: [ 'mySpecialKey' ]\n   * });\n   * ```\n   */\n  async createDataKey(provider) {\n    var _options$timeoutConte;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {\n      throw new errors_1.MongoCryptInvalidArgumentError(\"Option \\\"keyAltNames\\\" must be an array of strings, but was of type \".concat(typeof options.keyAltNames, \".\"));\n    }\n    let keyAltNames = undefined;\n    if (options.keyAltNames && options.keyAltNames.length > 0) {\n      keyAltNames = options.keyAltNames.map((keyAltName, i) => {\n        if (typeof keyAltName !== 'string') {\n          throw new errors_1.MongoCryptInvalidArgumentError(\"Option \\\"keyAltNames\\\" must be an array of strings, but item at index \".concat(i, \" was of type \").concat(typeof keyAltName));\n        }\n        return (0, bson_1.serialize)({\n          keyAltName\n        });\n      });\n    }\n    let keyMaterial = undefined;\n    if (options.keyMaterial) {\n      keyMaterial = (0, bson_1.serialize)({\n        keyMaterial: options.keyMaterial\n      });\n    }\n    const dataKeyBson = (0, bson_1.serialize)(_objectSpread({\n      provider\n    }, options.masterKey));\n    const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {\n      keyAltNames,\n      keyMaterial\n    });\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n    const timeoutContext = (_options$timeoutConte = options === null || options === void 0 ? void 0 : options.timeoutContext) !== null && _options$timeoutConte !== void 0 ? _options$timeoutConte : timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, {\n      timeoutMS: this._timeoutMS\n    }));\n    const dataKey = (0, bson_1.deserialize)(await stateMachine.execute(this, context, {\n      timeoutContext\n    }));\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const {\n      insertedId\n    } = await this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {\n      writeConcern: {\n        w: 'majority'\n      },\n      timeoutMS: timeoutContext !== null && timeoutContext !== void 0 && timeoutContext.csotEnabled() ? timeoutContext === null || timeoutContext === void 0 ? void 0 : timeoutContext.getRemainingTimeMSOrThrow() : undefined\n    });\n    return insertedId;\n  }\n  /**\n   * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.\n   *\n   * If no matches are found, then no bulk write is performed.\n   *\n   * @example\n   * ```ts\n   * // rewrapping all data data keys (using a filter that matches all documents)\n   * const filter = {};\n   *\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   * if (result.bulkWriteResult != null) {\n   *  // keys were re-wrapped, results will be available in the bulkWrite object.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // attempting to rewrap all data keys with no matches\n   * const filter = { _id: new Binary() } // assume _id matches no documents in the database\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   *\n   * if (result.bulkWriteResult == null) {\n   *  // no keys matched, `bulkWriteResult` does not exist on the result object\n   * }\n   * ```\n   */\n  async rewrapManyDataKey(filter, options) {\n    let keyEncryptionKeyBson = undefined;\n    if (options) {\n      const keyEncryptionKey = Object.assign({\n        provider: options.provider\n      }, options.masterKey);\n      keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);\n    }\n    const filterBson = (0, bson_1.serialize)(filter);\n    const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n    const timeoutContext = timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, {\n      timeoutMS: this._timeoutMS\n    }));\n    const {\n      v: dataKeys\n    } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, {\n      timeoutContext\n    }));\n    if (dataKeys.length === 0) {\n      return {};\n    }\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const replacements = dataKeys.map(key => ({\n      updateOne: {\n        filter: {\n          _id: key._id\n        },\n        update: {\n          $set: {\n            masterKey: key.masterKey,\n            keyMaterial: key.keyMaterial\n          },\n          $currentDate: {\n            updateDate: true\n          }\n        }\n      }\n    }));\n    const result = await this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {\n      writeConcern: {\n        w: 'majority'\n      },\n      timeoutMS: timeoutContext.csotEnabled() ? timeoutContext === null || timeoutContext === void 0 ? void 0 : timeoutContext.remainingTimeMS : undefined\n    });\n    return {\n      bulkWriteResult: result\n    };\n  }\n  /**\n   * Deletes the key with the provided id from the keyvault, if it exists.\n   *\n   * @example\n   * ```ts\n   * // delete a key by _id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const { deletedCount } = await clientEncryption.deleteKey(id);\n   *\n   * if (deletedCount != null && deletedCount > 0) {\n   *   // successful deletion\n   * }\n   * ```\n   *\n   */\n  async deleteKey(_id) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return await this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({\n      _id\n    }, {\n      writeConcern: {\n        w: 'majority'\n      },\n      timeoutMS: this._timeoutMS\n    });\n  }\n  /**\n   * Finds all the keys currently stored in the keyvault.\n   *\n   * This method will not throw.\n   *\n   * @returns a FindCursor over all keys in the keyvault.\n   * @example\n   * ```ts\n   * // fetching all keys\n   * const keys = await clientEncryption.getKeys().toArray();\n   * ```\n   */\n  getKeys() {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).find({}, {\n      readConcern: {\n        level: 'majority'\n      },\n      timeoutMS: this._timeoutMS\n    });\n  }\n  /**\n   * Finds a key in the keyvault with the specified _id.\n   *\n   * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // getting a key by id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const key = await clientEncryption.getKey(id);\n   * if (!key) {\n   *  // key is null if there was no matching key\n   * }\n   * ```\n   */\n  async getKey(_id) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({\n      _id\n    }, {\n      readConcern: {\n        level: 'majority'\n      },\n      timeoutMS: this._timeoutMS\n    });\n  }\n  /**\n   * Finds a key in the keyvault which has the specified keyAltName.\n   *\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the keyAltName.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // get a key by alt name\n   * const keyAltName = 'keyAltName';\n   * const key = await clientEncryption.getKeyByAltName(keyAltName);\n   * if (!key) {\n   *  // key is null if there is no matching key\n   * }\n   * ```\n   */\n  async getKeyByAltName(keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({\n      keyAltNames: keyAltName\n    }, {\n      readConcern: {\n        level: 'majority'\n      },\n      timeoutMS: this._timeoutMS\n    });\n  }\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // adding an keyAltName to a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  async addKeyAltName(_id, keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({\n      _id\n    }, {\n      $addToSet: {\n        keyAltNames: keyAltName\n      }\n    }, {\n      writeConcern: {\n        w: 'majority'\n      },\n      returnDocument: 'before',\n      timeoutMS: this._timeoutMS\n    });\n    return value;\n  }\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).\n   *\n   * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // removing a key alt name from a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);\n   *\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  async removeKeyAltName(_id, keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const pipeline = [{\n      $set: {\n        keyAltNames: {\n          $cond: [{\n            $eq: ['$keyAltNames', [keyAltName]]\n          }, '$$REMOVE', {\n            $filter: {\n              input: '$keyAltNames',\n              cond: {\n                $ne: ['$$this', keyAltName]\n              }\n            }\n          }]\n        }\n      }\n    }];\n    const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({\n      _id\n    }, pipeline, {\n      writeConcern: {\n        w: 'majority'\n      },\n      returnDocument: 'before',\n      timeoutMS: this._timeoutMS\n    });\n    return value;\n  }\n  /**\n   * A convenience method for creating an encrypted collection.\n   * This method will create data keys for any encryptedFields that do not have a `keyId` defined\n   * and then create a new collection with the full set of encryptedFields.\n   *\n   * @param db - A Node.js driver Db object with which to create the collection\n   * @param name - The name of the collection to be created\n   * @param options - Options for createDataKey and for createCollection\n   * @returns created collection and generated encryptedFields\n   * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.\n   * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.\n   */\n  async createEncryptedCollection(db, name, options) {\n    const {\n        provider,\n        masterKey\n      } = options,\n      encryptedFields = Object.assign({}, (_objectDestructuringEmpty(options.createCollectionOptions.encryptedFields), options.createCollectionOptions.encryptedFields)),\n      createCollectionOptions = Object.assign({}, (_objectDestructuringEmpty(options.createCollectionOptions), options.createCollectionOptions));\n    const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, {\n      timeoutMS: this._timeoutMS\n    })) : undefined;\n    if (Array.isArray(encryptedFields.fields)) {\n      const createDataKeyPromises = encryptedFields.fields.map(async field => field == null || typeof field !== 'object' || field.keyId != null ? field : _objectSpread(_objectSpread({}, field), {}, {\n        keyId: await this.createDataKey(provider, {\n          masterKey,\n          // clone the timeoutContext\n          // in order to avoid sharing the same timeout for server selection and connection checkout across different concurrent operations\n          timeoutContext: timeoutContext !== null && timeoutContext !== void 0 && timeoutContext.csotEnabled() ? timeoutContext === null || timeoutContext === void 0 ? void 0 : timeoutContext.clone() : undefined\n        })\n      }));\n      const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);\n      encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === 'fulfilled' ? resolution.value : encryptedFields.fields[index]);\n      const rejection = createDataKeyResolutions.find(result => result.status === 'rejected');\n      if (rejection != null) {\n        throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, {\n          cause: rejection.reason\n        });\n      }\n    }\n    try {\n      const collection = await db.createCollection(name, _objectSpread(_objectSpread({}, createCollectionOptions), {}, {\n        encryptedFields,\n        timeoutMS: timeoutContext !== null && timeoutContext !== void 0 && timeoutContext.csotEnabled() ? timeoutContext === null || timeoutContext === void 0 ? void 0 : timeoutContext.getRemainingTimeMSOrThrow() : undefined\n      }));\n      return {\n        collection,\n        encryptedFields\n      };\n    } catch (cause) {\n      throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, {\n        cause\n      });\n    }\n  }\n  /**\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON\n   * @param options -\n   * @returns a Promise that either resolves with the encrypted value, or rejects with an error.\n   *\n   * @example\n   * ```ts\n   * // Encryption with async/await api\n   * async function encryptMyData(value) {\n   *   const keyId = await clientEncryption.createDataKey('local');\n   *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Encryption using a keyAltName\n   * async function encryptMyData(value) {\n   *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n   *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   */\n  async encrypt(value, options) {\n    return await this._encrypt(value, false, options);\n  }\n  /**\n   * Encrypts a Match Expression or Aggregate Expression to query a range index.\n   *\n   * Only supported when queryType is \"range\" and algorithm is \"Range\".\n   *\n   * @param expression - a BSON document of one of the following forms:\n   *  1. A Match Expression of this form:\n   *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`\n   *  2. An Aggregate Expression of this form:\n   *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`\n   *\n   *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.\n   *\n   * @param options -\n   * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.\n   */\n  async encryptExpression(expression, options) {\n    return await this._encrypt(expression, true, options);\n  }\n  /**\n   * Explicitly decrypt a provided encrypted value\n   *\n   * @param value - An encrypted value\n   * @returns a Promise that either resolves with the decrypted value, or rejects with an error\n   *\n   * @example\n   * ```ts\n   * // Decrypting value with async/await API\n   * async function decryptMyValue(value) {\n   *   return clientEncryption.decrypt(value);\n   * }\n   * ```\n   */\n  async decrypt(value) {\n    const valueBuffer = (0, bson_1.serialize)({\n      v: value\n    });\n    const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n    const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, {\n      timeoutMS: this._timeoutMS\n    })) : undefined;\n    const {\n      v\n    } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, {\n      timeoutContext\n    }));\n    return v;\n  }\n  /**\n   * @internal\n   * Ask the user for KMS credentials.\n   *\n   * This returns anything that looks like the kmsProviders original input\n   * option. It can be empty, and any provider specified here will override\n   * the original ones.\n   */\n  async askForKMSCredentials() {\n    return await (0, index_1.refreshKMSCredentials)(this._kmsProviders);\n  }\n  static get libmongocryptVersion() {\n    return ClientEncryption.getMongoCrypt().libmongocryptVersion;\n  }\n  /**\n   * @internal\n   * A helper that perform explicit encryption of values and expressions.\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON\n   * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression\n   * @param options - options to pass to encrypt\n   * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return\n   *          value will be a bson document.  When false, the value will be a BSON Binary.\n   *\n   */\n  async _encrypt(value, expressionMode, options) {\n    const {\n      algorithm,\n      keyId,\n      keyAltName,\n      contentionFactor,\n      queryType,\n      rangeOptions\n    } = options;\n    const contextOptions = {\n      expressionMode,\n      algorithm\n    };\n    if (keyId) {\n      contextOptions.keyId = keyId.buffer;\n    }\n    if (keyAltName) {\n      if (keyId) {\n        throw new errors_1.MongoCryptInvalidArgumentError(\"\\\"options\\\" cannot contain both \\\"keyId\\\" and \\\"keyAltName\\\"\");\n      }\n      if (typeof keyAltName !== 'string') {\n        throw new errors_1.MongoCryptInvalidArgumentError(\"\\\"options.keyAltName\\\" must be of type string, but was of type \".concat(typeof keyAltName));\n      }\n      contextOptions.keyAltName = (0, bson_1.serialize)({\n        keyAltName\n      });\n    }\n    if (typeof contentionFactor === 'number' || typeof contentionFactor === 'bigint') {\n      contextOptions.contentionFactor = contentionFactor;\n    }\n    if (typeof queryType === 'string') {\n      contextOptions.queryType = queryType;\n    }\n    if (typeof rangeOptions === 'object') {\n      contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);\n    }\n    const valueBuffer = (0, bson_1.serialize)({\n      v: value\n    });\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n    const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n    const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, {\n      timeoutMS: this._timeoutMS\n    })) : undefined;\n    const {\n      v\n    } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, {\n      timeoutContext\n    }));\n    return v;\n  }\n}\nexports.ClientEncryption = ClientEncryption;\n/**\n * Get the socket options from the client.\n * @param baseOptions - The mongo client options.\n * @returns ClientEncryptionSocketOptions\n */\nfunction autoSelectSocketOptions(baseOptions) {\n  const options = {\n    autoSelectFamily: true\n  };\n  if ('autoSelectFamily' in baseOptions) {\n    options.autoSelectFamily = baseOptions.autoSelectFamily;\n  }\n  if ('autoSelectFamilyAttemptTimeout' in baseOptions) {\n    options.autoSelectFamilyAttemptTimeout = baseOptions.autoSelectFamilyAttemptTimeout;\n  }\n  return options;\n}","map":{"version":3,"names":["exports","autoSelectSocketOptions","bson_1","require","deps_1","timeout_1","utils_1","cryptoCallbacks","errors_1","index_1","state_machine_1","ClientEncryption","getMongoCrypt","encryption","getMongoDBClientEncryption","kModuleError","MongoCrypt","constructor","client","options","_options$proxyOptions","_options$tlsOptions","_client","_proxyOptions","proxyOptions","_tlsOptions","tlsOptions","_kmsProviders","kmsProviders","timeoutMS","resolveTimeoutOptions","_timeoutMS","keyVaultNamespace","MongoCryptInvalidArgumentError","mongoCryptOptions","_objectSpread","Buffer","isBuffer","serialize","_keyVaultNamespace","_keyVaultClient","keyVaultClient","_mongoCrypt","createDataKey","provider","_options$timeoutConte","arguments","length","undefined","keyAltNames","Array","isArray","concat","map","keyAltName","i","keyMaterial","dataKeyBson","masterKey","context","makeDataKeyContext","stateMachine","StateMachine","socketOptions","s","timeoutContext","TimeoutContext","create","dataKey","deserialize","execute","db","dbName","collection","collectionName","MongoDBCollectionNamespace","fromString","insertedId","insertOne","writeConcern","w","csotEnabled","getRemainingTimeMSOrThrow","rewrapManyDataKey","filter","keyEncryptionKeyBson","keyEncryptionKey","Object","assign","filterBson","makeRewrapManyDataKeyContext","v","dataKeys","replacements","key","updateOne","_id","update","$set","$currentDate","updateDate","result","bulkWrite","remainingTimeMS","bulkWriteResult","deleteKey","deleteOne","getKeys","find","readConcern","level","getKey","findOne","getKeyByAltName","addKeyAltName","value","findOneAndUpdate","$addToSet","returnDocument","removeKeyAltName","pipeline","$cond","$eq","$filter","input","cond","$ne","createEncryptedCollection","name","encryptedFields","_objectDestructuringEmpty","createCollectionOptions","fields","createDataKeyPromises","field","keyId","clone","createDataKeyResolutions","Promise","allSettled","resolution","index","status","rejection","MongoCryptCreateDataKeyError","cause","reason","createCollection","MongoCryptCreateEncryptedCollectionError","encrypt","_encrypt","encryptExpression","expression","decrypt","valueBuffer","makeExplicitDecryptionContext","askForKMSCredentials","refreshKMSCredentials","libmongocryptVersion","expressionMode","algorithm","contentionFactor","queryType","rangeOptions","contextOptions","buffer","makeExplicitEncryptionContext","baseOptions","autoSelectFamily","autoSelectFamilyAttemptTimeout"],"sources":["/Users/glebch/workprojects/baumna/client/node_modules/mongodb/src/client-side-encryption/client_encryption.ts"],"sourcesContent":["import type {\n  ExplicitEncryptionContextOptions,\n  MongoCrypt,\n  MongoCryptConstructor,\n  MongoCryptOptions\n} from 'mongodb-client-encryption';\n\nimport {\n  type Binary,\n  deserialize,\n  type Document,\n  type Int32,\n  type Long,\n  serialize,\n  type UUID\n} from '../bson';\nimport { type AnyBulkWriteOperation, type BulkWriteResult } from '../bulk/common';\nimport { type ProxyOptions } from '../cmap/connection';\nimport { type Collection } from '../collection';\nimport { type FindCursor } from '../cursor/find_cursor';\nimport { type Db } from '../db';\nimport { getMongoDBClientEncryption } from '../deps';\nimport { type MongoClient, type MongoClientOptions } from '../mongo_client';\nimport { type Filter, type WithId } from '../mongo_types';\nimport { type CreateCollectionOptions } from '../operations/create_collection';\nimport { type DeleteResult } from '../operations/delete';\nimport { type CSOTTimeoutContext, TimeoutContext } from '../timeout';\nimport { MongoDBCollectionNamespace, resolveTimeoutOptions } from '../utils';\nimport * as cryptoCallbacks from './crypto_callbacks';\nimport {\n  MongoCryptCreateDataKeyError,\n  MongoCryptCreateEncryptedCollectionError,\n  MongoCryptInvalidArgumentError\n} from './errors';\nimport {\n  type ClientEncryptionDataKeyProvider,\n  type KMSProviders,\n  refreshKMSCredentials\n} from './providers/index';\nimport {\n  type ClientEncryptionSocketOptions,\n  type CSFLEKMSTlsOptions,\n  StateMachine\n} from './state_machine';\n\n/**\n * @public\n * The schema for a DataKey in the key vault collection.\n */\nexport interface DataKey {\n  _id: UUID;\n  version?: number;\n  keyAltNames?: string[];\n  keyMaterial: Binary;\n  creationDate: Date;\n  updateDate: Date;\n  status: number;\n  masterKey: Document;\n}\n\n/**\n * @public\n * The public interface for explicit in-use encryption\n */\nexport class ClientEncryption {\n  /** @internal */\n  _client: MongoClient;\n  /** @internal */\n  _keyVaultNamespace: string;\n  /** @internal */\n  _keyVaultClient: MongoClient;\n  /** @internal */\n  _proxyOptions: ProxyOptions;\n  /** @internal */\n  _tlsOptions: CSFLEKMSTlsOptions;\n  /** @internal */\n  _kmsProviders: KMSProviders;\n  /** @internal */\n  _timeoutMS?: number;\n\n  /** @internal */\n  _mongoCrypt: MongoCrypt;\n\n  /** @internal */\n  static getMongoCrypt(): MongoCryptConstructor {\n    const encryption = getMongoDBClientEncryption();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n\n  /**\n   * Create a new encryption instance\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     local: {\n   *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     aws: {\n   *       accessKeyId: AWS_ACCESS_KEY,\n   *       secretAccessKey: AWS_SECRET_KEY\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  constructor(client: MongoClient, options: ClientEncryptionOptions) {\n    this._client = client;\n    this._proxyOptions = options.proxyOptions ?? {};\n    this._tlsOptions = options.tlsOptions ?? {};\n    this._kmsProviders = options.kmsProviders || {};\n    const { timeoutMS } = resolveTimeoutOptions(client, options);\n    this._timeoutMS = timeoutMS;\n\n    if (options.keyVaultNamespace == null) {\n      throw new MongoCryptInvalidArgumentError('Missing required option `keyVaultNamespace`');\n    }\n\n    const mongoCryptOptions: MongoCryptOptions = {\n      ...options,\n      cryptoCallbacks,\n      kmsProviders: !Buffer.isBuffer(this._kmsProviders)\n        ? (serialize(this._kmsProviders) as Buffer)\n        : this._kmsProviders\n    };\n\n    this._keyVaultNamespace = options.keyVaultNamespace;\n    this._keyVaultClient = options.keyVaultClient || client;\n    const MongoCrypt = ClientEncryption.getMongoCrypt();\n    this._mongoCrypt = new MongoCrypt(mongoCryptOptions);\n  }\n\n  /**\n   * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create a local key\n   * const dataKeyId = await clientEncryption.createDataKey('local');\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key with a keyAltName\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   },\n   *   keyAltNames: [ 'mySpecialKey' ]\n   * });\n   * ```\n   */\n  async createDataKey(\n    provider: ClientEncryptionDataKeyProvider,\n    options: ClientEncryptionCreateDataKeyProviderOptions = {}\n  ): Promise<UUID> {\n    if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {\n      throw new MongoCryptInvalidArgumentError(\n        `Option \"keyAltNames\" must be an array of strings, but was of type ${typeof options.keyAltNames}.`\n      );\n    }\n\n    let keyAltNames = undefined;\n    if (options.keyAltNames && options.keyAltNames.length > 0) {\n      keyAltNames = options.keyAltNames.map((keyAltName, i) => {\n        if (typeof keyAltName !== 'string') {\n          throw new MongoCryptInvalidArgumentError(\n            `Option \"keyAltNames\" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`\n          );\n        }\n\n        return serialize({ keyAltName });\n      });\n    }\n\n    let keyMaterial = undefined;\n    if (options.keyMaterial) {\n      keyMaterial = serialize({ keyMaterial: options.keyMaterial });\n    }\n\n    const dataKeyBson = serialize({\n      provider,\n      ...options.masterKey\n    });\n\n    const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {\n      keyAltNames,\n      keyMaterial\n    });\n\n    const stateMachine = new StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n\n    const timeoutContext =\n      options?.timeoutContext ??\n      TimeoutContext.create(resolveTimeoutOptions(this._client, { timeoutMS: this._timeoutMS }));\n\n    const dataKey = deserialize(\n      await stateMachine.execute(this, context, { timeoutContext })\n    ) as DataKey;\n\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    const { insertedId } = await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .insertOne(dataKey, {\n        writeConcern: { w: 'majority' },\n        timeoutMS: timeoutContext?.csotEnabled()\n          ? timeoutContext?.getRemainingTimeMSOrThrow()\n          : undefined\n      });\n\n    return insertedId;\n  }\n\n  /**\n   * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.\n   *\n   * If no matches are found, then no bulk write is performed.\n   *\n   * @example\n   * ```ts\n   * // rewrapping all data data keys (using a filter that matches all documents)\n   * const filter = {};\n   *\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   * if (result.bulkWriteResult != null) {\n   *  // keys were re-wrapped, results will be available in the bulkWrite object.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // attempting to rewrap all data keys with no matches\n   * const filter = { _id: new Binary() } // assume _id matches no documents in the database\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   *\n   * if (result.bulkWriteResult == null) {\n   *  // no keys matched, `bulkWriteResult` does not exist on the result object\n   * }\n   * ```\n   */\n  async rewrapManyDataKey(\n    filter: Filter<DataKey>,\n    options: ClientEncryptionRewrapManyDataKeyProviderOptions\n  ): Promise<{ bulkWriteResult?: BulkWriteResult }> {\n    let keyEncryptionKeyBson = undefined;\n    if (options) {\n      const keyEncryptionKey = Object.assign({ provider: options.provider }, options.masterKey);\n      keyEncryptionKeyBson = serialize(keyEncryptionKey);\n    }\n    const filterBson = serialize(filter);\n    const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);\n    const stateMachine = new StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n\n    const timeoutContext = TimeoutContext.create(\n      resolveTimeoutOptions(this._client, { timeoutMS: this._timeoutMS })\n    );\n\n    const { v: dataKeys } = deserialize(\n      await stateMachine.execute(this, context, { timeoutContext })\n    );\n    if (dataKeys.length === 0) {\n      return {};\n    }\n\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    const replacements = dataKeys.map(\n      (key: DataKey): AnyBulkWriteOperation<DataKey> => ({\n        updateOne: {\n          filter: { _id: key._id },\n          update: {\n            $set: {\n              masterKey: key.masterKey,\n              keyMaterial: key.keyMaterial\n            },\n            $currentDate: {\n              updateDate: true\n            }\n          }\n        }\n      })\n    );\n\n    const result = await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .bulkWrite(replacements, {\n        writeConcern: { w: 'majority' },\n        timeoutMS: timeoutContext.csotEnabled() ? timeoutContext?.remainingTimeMS : undefined\n      });\n\n    return { bulkWriteResult: result };\n  }\n\n  /**\n   * Deletes the key with the provided id from the keyvault, if it exists.\n   *\n   * @example\n   * ```ts\n   * // delete a key by _id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const { deletedCount } = await clientEncryption.deleteKey(id);\n   *\n   * if (deletedCount != null && deletedCount > 0) {\n   *   // successful deletion\n   * }\n   * ```\n   *\n   */\n  async deleteKey(_id: Binary): Promise<DeleteResult> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    return await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .deleteOne({ _id }, { writeConcern: { w: 'majority' }, timeoutMS: this._timeoutMS });\n  }\n\n  /**\n   * Finds all the keys currently stored in the keyvault.\n   *\n   * This method will not throw.\n   *\n   * @returns a FindCursor over all keys in the keyvault.\n   * @example\n   * ```ts\n   * // fetching all keys\n   * const keys = await clientEncryption.getKeys().toArray();\n   * ```\n   */\n  getKeys(): FindCursor<DataKey> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    return this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .find({}, { readConcern: { level: 'majority' }, timeoutMS: this._timeoutMS });\n  }\n\n  /**\n   * Finds a key in the keyvault with the specified _id.\n   *\n   * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // getting a key by id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const key = await clientEncryption.getKey(id);\n   * if (!key) {\n   *  // key is null if there was no matching key\n   * }\n   * ```\n   */\n  async getKey(_id: Binary): Promise<DataKey | null> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    return await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .findOne({ _id }, { readConcern: { level: 'majority' }, timeoutMS: this._timeoutMS });\n  }\n\n  /**\n   * Finds a key in the keyvault which has the specified keyAltName.\n   *\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the keyAltName.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // get a key by alt name\n   * const keyAltName = 'keyAltName';\n   * const key = await clientEncryption.getKeyByAltName(keyAltName);\n   * if (!key) {\n   *  // key is null if there is no matching key\n   * }\n   * ```\n   */\n  async getKeyByAltName(keyAltName: string): Promise<WithId<DataKey> | null> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    return await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .findOne(\n        { keyAltNames: keyAltName },\n        { readConcern: { level: 'majority' }, timeoutMS: this._timeoutMS }\n      );\n  }\n\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // adding an keyAltName to a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  async addKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    const value = await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .findOneAndUpdate(\n        { _id },\n        { $addToSet: { keyAltNames: keyAltName } },\n        { writeConcern: { w: 'majority' }, returnDocument: 'before', timeoutMS: this._timeoutMS }\n      );\n\n    return value;\n  }\n\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).\n   *\n   * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // removing a key alt name from a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);\n   *\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  async removeKeyAltName(_id: Binary, keyAltName: string): Promise<WithId<DataKey> | null> {\n    const { db: dbName, collection: collectionName } = MongoDBCollectionNamespace.fromString(\n      this._keyVaultNamespace\n    );\n\n    const pipeline = [\n      {\n        $set: {\n          keyAltNames: {\n            $cond: [\n              {\n                $eq: ['$keyAltNames', [keyAltName]]\n              },\n              '$$REMOVE',\n              {\n                $filter: {\n                  input: '$keyAltNames',\n                  cond: {\n                    $ne: ['$$this', keyAltName]\n                  }\n                }\n              }\n            ]\n          }\n        }\n      }\n    ];\n\n    const value = await this._keyVaultClient\n      .db(dbName)\n      .collection<DataKey>(collectionName)\n      .findOneAndUpdate({ _id }, pipeline, {\n        writeConcern: { w: 'majority' },\n        returnDocument: 'before',\n        timeoutMS: this._timeoutMS\n      });\n\n    return value;\n  }\n\n  /**\n   * A convenience method for creating an encrypted collection.\n   * This method will create data keys for any encryptedFields that do not have a `keyId` defined\n   * and then create a new collection with the full set of encryptedFields.\n   *\n   * @param db - A Node.js driver Db object with which to create the collection\n   * @param name - The name of the collection to be created\n   * @param options - Options for createDataKey and for createCollection\n   * @returns created collection and generated encryptedFields\n   * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.\n   * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.\n   */\n  async createEncryptedCollection<TSchema extends Document = Document>(\n    db: Db,\n    name: string,\n    options: {\n      provider: ClientEncryptionDataKeyProvider;\n      createCollectionOptions: Omit<CreateCollectionOptions, 'encryptedFields'> & {\n        encryptedFields: Document;\n      };\n      masterKey?: AWSEncryptionKeyOptions | AzureEncryptionKeyOptions | GCPEncryptionKeyOptions;\n    }\n  ): Promise<{ collection: Collection<TSchema>; encryptedFields: Document }> {\n    const {\n      provider,\n      masterKey,\n      createCollectionOptions: {\n        encryptedFields: { ...encryptedFields },\n        ...createCollectionOptions\n      }\n    } = options;\n\n    const timeoutContext =\n      this._timeoutMS != null\n        ? TimeoutContext.create(resolveTimeoutOptions(this._client, { timeoutMS: this._timeoutMS }))\n        : undefined;\n\n    if (Array.isArray(encryptedFields.fields)) {\n      const createDataKeyPromises = encryptedFields.fields.map(async field =>\n        field == null || typeof field !== 'object' || field.keyId != null\n          ? field\n          : {\n              ...field,\n              keyId: await this.createDataKey(provider, {\n                masterKey,\n                // clone the timeoutContext\n                // in order to avoid sharing the same timeout for server selection and connection checkout across different concurrent operations\n                timeoutContext: timeoutContext?.csotEnabled() ? timeoutContext?.clone() : undefined\n              })\n            }\n      );\n      const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);\n\n      encryptedFields.fields = createDataKeyResolutions.map((resolution, index) =>\n        resolution.status === 'fulfilled' ? resolution.value : encryptedFields.fields[index]\n      );\n\n      const rejection = createDataKeyResolutions.find(\n        (result): result is PromiseRejectedResult => result.status === 'rejected'\n      );\n      if (rejection != null) {\n        throw new MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });\n      }\n    }\n\n    try {\n      const collection = await db.createCollection<TSchema>(name, {\n        ...createCollectionOptions,\n        encryptedFields,\n        timeoutMS: timeoutContext?.csotEnabled()\n          ? timeoutContext?.getRemainingTimeMSOrThrow()\n          : undefined\n      });\n      return { collection, encryptedFields };\n    } catch (cause) {\n      throw new MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });\n    }\n  }\n\n  /**\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON\n   * @param options -\n   * @returns a Promise that either resolves with the encrypted value, or rejects with an error.\n   *\n   * @example\n   * ```ts\n   * // Encryption with async/await api\n   * async function encryptMyData(value) {\n   *   const keyId = await clientEncryption.createDataKey('local');\n   *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Encryption using a keyAltName\n   * async function encryptMyData(value) {\n   *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n   *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   */\n  async encrypt(value: unknown, options: ClientEncryptionEncryptOptions): Promise<Binary> {\n    return await this._encrypt(value, false, options);\n  }\n\n  /**\n   * Encrypts a Match Expression or Aggregate Expression to query a range index.\n   *\n   * Only supported when queryType is \"range\" and algorithm is \"Range\".\n   *\n   * @param expression - a BSON document of one of the following forms:\n   *  1. A Match Expression of this form:\n   *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`\n   *  2. An Aggregate Expression of this form:\n   *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`\n   *\n   *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.\n   *\n   * @param options -\n   * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.\n   */\n  async encryptExpression(\n    expression: Document,\n    options: ClientEncryptionEncryptOptions\n  ): Promise<Binary> {\n    return await this._encrypt(expression, true, options);\n  }\n\n  /**\n   * Explicitly decrypt a provided encrypted value\n   *\n   * @param value - An encrypted value\n   * @returns a Promise that either resolves with the decrypted value, or rejects with an error\n   *\n   * @example\n   * ```ts\n   * // Decrypting value with async/await API\n   * async function decryptMyValue(value) {\n   *   return clientEncryption.decrypt(value);\n   * }\n   * ```\n   */\n  async decrypt<T = any>(value: Binary): Promise<T> {\n    const valueBuffer = serialize({ v: value });\n    const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n\n    const stateMachine = new StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n\n    const timeoutContext =\n      this._timeoutMS != null\n        ? TimeoutContext.create(resolveTimeoutOptions(this._client, { timeoutMS: this._timeoutMS }))\n        : undefined;\n\n    const { v } = deserialize(await stateMachine.execute(this, context, { timeoutContext }));\n\n    return v;\n  }\n\n  /**\n   * @internal\n   * Ask the user for KMS credentials.\n   *\n   * This returns anything that looks like the kmsProviders original input\n   * option. It can be empty, and any provider specified here will override\n   * the original ones.\n   */\n  async askForKMSCredentials(): Promise<KMSProviders> {\n    return await refreshKMSCredentials(this._kmsProviders);\n  }\n\n  static get libmongocryptVersion() {\n    return ClientEncryption.getMongoCrypt().libmongocryptVersion;\n  }\n\n  /**\n   * @internal\n   * A helper that perform explicit encryption of values and expressions.\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON\n   * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression\n   * @param options - options to pass to encrypt\n   * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return\n   *          value will be a bson document.  When false, the value will be a BSON Binary.\n   *\n   */\n  private async _encrypt(\n    value: unknown,\n    expressionMode: boolean,\n    options: ClientEncryptionEncryptOptions\n  ): Promise<Binary> {\n    const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options;\n    const contextOptions: ExplicitEncryptionContextOptions = {\n      expressionMode,\n      algorithm\n    };\n    if (keyId) {\n      contextOptions.keyId = keyId.buffer;\n    }\n    if (keyAltName) {\n      if (keyId) {\n        throw new MongoCryptInvalidArgumentError(\n          `\"options\" cannot contain both \"keyId\" and \"keyAltName\"`\n        );\n      }\n      if (typeof keyAltName !== 'string') {\n        throw new MongoCryptInvalidArgumentError(\n          `\"options.keyAltName\" must be of type string, but was of type ${typeof keyAltName}`\n        );\n      }\n\n      contextOptions.keyAltName = serialize({ keyAltName });\n    }\n    if (typeof contentionFactor === 'number' || typeof contentionFactor === 'bigint') {\n      contextOptions.contentionFactor = contentionFactor;\n    }\n    if (typeof queryType === 'string') {\n      contextOptions.queryType = queryType;\n    }\n\n    if (typeof rangeOptions === 'object') {\n      contextOptions.rangeOptions = serialize(rangeOptions);\n    }\n\n    const valueBuffer = serialize({ v: value });\n    const stateMachine = new StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n    const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n\n    const timeoutContext =\n      this._timeoutMS != null\n        ? TimeoutContext.create(resolveTimeoutOptions(this._client, { timeoutMS: this._timeoutMS }))\n        : undefined;\n    const { v } = deserialize(await stateMachine.execute(this, context, { timeoutContext }));\n    return v;\n  }\n}\n\n/**\n * @public\n * Options to provide when encrypting data.\n */\nexport interface ClientEncryptionEncryptOptions {\n  /**\n   * The algorithm to use for encryption.\n   */\n  algorithm:\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'\n    | 'AEAD_AES_256_CBC_HMAC_SHA_512-Random'\n    | 'Indexed'\n    | 'Unindexed'\n    | 'Range';\n\n  /**\n   * The id of the Binary dataKey to use for encryption\n   */\n  keyId?: Binary;\n\n  /**\n   * A unique string name corresponding to an already existing dataKey.\n   */\n  keyAltName?: string;\n\n  /** The contention factor. */\n  contentionFactor?: bigint | number;\n\n  /**\n   * The query type.\n   */\n  queryType?: 'equality' | 'range';\n\n  /** The index options for a Queryable Encryption field supporting \"range\" queries.*/\n  rangeOptions?: RangeOptions;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface ClientEncryptionRewrapManyDataKeyProviderOptions {\n  provider: ClientEncryptionDataKeyProvider;\n  masterKey?:\n    | AWSEncryptionKeyOptions\n    | AzureEncryptionKeyOptions\n    | GCPEncryptionKeyOptions\n    | KMIPEncryptionKeyOptions\n    | undefined;\n}\n\n/**\n * @public\n * Additional settings to provide when creating a new `ClientEncryption` instance.\n */\nexport interface ClientEncryptionOptions {\n  /**\n   * The namespace of the key vault, used to store encryption keys\n   */\n  keyVaultNamespace: string;\n\n  /**\n   * A MongoClient used to fetch keys from a key vault. Defaults to client.\n   */\n  keyVaultClient?: MongoClient | undefined;\n\n  /**\n   * Options for specific KMS providers to use\n   */\n  kmsProviders?: KMSProviders;\n\n  /**\n   * Options for specifying a Socks5 proxy to use for connecting to the KMS.\n   */\n  proxyOptions?: ProxyOptions;\n\n  /**\n   * TLS options for kms providers to use.\n   */\n  tlsOptions?: CSFLEKMSTlsOptions;\n\n  /**\n   * @experimental\n   *\n   * The timeout setting to be used for all the operations on ClientEncryption.\n   *\n   * When provided, `timeoutMS` is used as the timeout for each operation executed on\n   * the ClientEncryption object.  For example:\n   *\n   * ```typescript\n   * const clientEncryption = new ClientEncryption(client, {\n   *  timeoutMS: 1_000\n   *  kmsProviders: { local: { key: '<KEY>' } }\n   * });\n   *\n   * // `1_000` is used as the timeout for createDataKey call\n   * await clientEncryption.createDataKey('local');\n   * ```\n   *\n   * If `timeoutMS` is configured on the provided client, the client's `timeoutMS` value\n   * will be used unless `timeoutMS` is also provided as a client encryption option.\n   *\n   * ```typescript\n   * const client = new MongoClient('<uri>', { timeoutMS: 2_000 });\n   *\n   * // timeoutMS is set to 1_000 on clientEncryption\n   * const clientEncryption = new ClientEncryption(client, {\n   *  timeoutMS: 1_000\n   *  kmsProviders: { local: { key: '<KEY>' } }\n   * });\n   * ```\n   */\n  timeoutMS?: number;\n}\n\n/**\n * @public\n * Configuration options for making an AWS encryption key\n */\nexport interface AWSEncryptionKeyOptions {\n  /**\n   * The AWS region of the KMS\n   */\n  region: string;\n\n  /**\n   * The Amazon Resource Name (ARN) to the AWS customer master key (CMK)\n   */\n  key: string;\n\n  /**\n   * An alternate host to send KMS requests to. May include port number.\n   */\n  endpoint?: string | undefined;\n}\n\n/**\n * @public\n * Configuration options for making an AWS encryption key\n */\nexport interface GCPEncryptionKeyOptions {\n  /**\n   * GCP project ID\n   */\n  projectId: string;\n\n  /**\n   * Location name (e.g. \"global\")\n   */\n  location: string;\n\n  /**\n   * Key ring name\n   */\n  keyRing: string;\n\n  /**\n   * Key name\n   */\n  keyName: string;\n\n  /**\n   * Key version\n   */\n  keyVersion?: string | undefined;\n\n  /**\n   * KMS URL, defaults to `https://www.googleapis.com/auth/cloudkms`\n   */\n  endpoint?: string | undefined;\n}\n\n/**\n * @public\n * Configuration options for making an Azure encryption key\n */\nexport interface AzureEncryptionKeyOptions {\n  /**\n   * Key name\n   */\n  keyName: string;\n\n  /**\n   * Key vault URL, typically `<name>.vault.azure.net`\n   */\n  keyVaultEndpoint: string;\n\n  /**\n   * Key version\n   */\n  keyVersion?: string | undefined;\n}\n\n/**\n * @public\n * Configuration options for making a KMIP encryption key\n */\nexport interface KMIPEncryptionKeyOptions {\n  /**\n   * keyId is the KMIP Unique Identifier to a 96 byte KMIP Secret Data managed object.\n   *\n   * If keyId is omitted, a random 96 byte KMIP Secret Data managed object will be created.\n   */\n  keyId?: string;\n\n  /**\n   * Host with optional port.\n   */\n  endpoint?: string;\n\n  /**\n   * If true, this key should be decrypted by the KMIP server.\n   *\n   * Requires `mongodb-client-encryption>=6.0.1`.\n   */\n  delegated?: boolean;\n}\n\n/**\n * @public\n * Options to provide when creating a new data key.\n */\nexport interface ClientEncryptionCreateDataKeyProviderOptions {\n  /**\n   * Identifies a new KMS-specific key used to encrypt the new data key\n   */\n  masterKey?:\n    | AWSEncryptionKeyOptions\n    | AzureEncryptionKeyOptions\n    | GCPEncryptionKeyOptions\n    | KMIPEncryptionKeyOptions\n    | undefined;\n\n  /**\n   * An optional list of string alternate names used to reference a key.\n   * If a key is created with alternate names, then encryption may refer to the key by the unique alternate name instead of by _id.\n   */\n  keyAltNames?: string[] | undefined;\n\n  /** @experimental */\n  keyMaterial?: Buffer | Binary;\n\n  /** @internal */\n  timeoutContext?: CSOTTimeoutContext;\n}\n\n/**\n * @public\n * @experimental\n */\nexport interface ClientEncryptionRewrapManyDataKeyResult {\n  /** The result of rewrapping data keys. If unset, no keys matched the filter. */\n  bulkWriteResult?: BulkWriteResult;\n}\n\n/**\n * @public\n * RangeOptions specifies index options for a Queryable Encryption field supporting \"range\" queries.\n * min, max, sparsity, trimFactor and range must match the values set in the encryptedFields of the destination collection.\n * For double and decimal128, min/max/precision must all be set, or all be unset.\n */\nexport interface RangeOptions {\n  /** min is the minimum value for the encrypted index. Required if precision is set. */\n  min?: any;\n  /** max is the minimum value for the encrypted index. Required if precision is set. */\n  max?: any;\n  /** sparsity may be used to tune performance. must be non-negative. When omitted, a default value is used. */\n  sparsity?: Long | bigint;\n  /** trimFactor may be used to tune performance. must be non-negative. When omitted, a default value is used. */\n  trimFactor?: Int32 | number;\n  /* precision determines the number of significant digits after the decimal point. May only be set for double or decimal128. */\n  precision?: number;\n}\n\n/**\n * Get the socket options from the client.\n * @param baseOptions - The mongo client options.\n * @returns ClientEncryptionSocketOptions\n */\nexport function autoSelectSocketOptions(\n  baseOptions: MongoClientOptions\n): ClientEncryptionSocketOptions {\n  const options: ClientEncryptionSocketOptions = { autoSelectFamily: true };\n  if ('autoSelectFamily' in baseOptions) {\n    options.autoSelectFamily = baseOptions.autoSelectFamily;\n  }\n  if ('autoSelectFamilyAttemptTimeout' in baseOptions) {\n    options.autoSelectFamilyAttemptTimeout = baseOptions.autoSelectFamilyAttemptTimeout;\n  }\n  return options;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}