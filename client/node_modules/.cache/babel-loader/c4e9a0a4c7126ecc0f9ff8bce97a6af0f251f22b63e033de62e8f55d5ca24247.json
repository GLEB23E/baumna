{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/glebch/workprojects/baumna/client/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"../write_concern\");\nconst bulk_write_1 = require(\"./bulk_write\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass InsertOperation extends command_1.CommandOperation {\n  constructor(ns, documents, options) {\n    var _options$checkKeys;\n    super(undefined, options);\n    this.options = _objectSpread(_objectSpread({}, options), {}, {\n      checkKeys: (_options$checkKeys = options.checkKeys) !== null && _options$checkKeys !== void 0 ? _options$checkKeys : false\n    });\n    this.ns = ns;\n    this.documents = documents;\n  }\n  get commandName() {\n    return 'insert';\n  }\n  async execute(server, session, timeoutContext) {\n    var _this$options;\n    const options = (_this$options = this.options) !== null && _this$options !== void 0 ? _this$options : {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n    return await super.executeCommand(server, session, command, timeoutContext);\n  }\n}\nexports.InsertOperation = InsertOperation;\nclass InsertOneOperation extends InsertOperation {\n  constructor(collection, doc, options) {\n    super(collection.s.namespace, (0, utils_1.maybeAddIdToDocuments)(collection, [doc], options), options);\n  }\n  async execute(server, session, timeoutContext) {\n    var _this$writeConcern;\n    const res = await super.execute(server, session, timeoutContext);\n    if (res.code) throw new error_1.MongoServerError(res);\n    if (res.writeErrors) {\n      // This should be a WriteError but we can't change it now because of error hierarchy\n      throw new error_1.MongoServerError(res.writeErrors[0]);\n    }\n    return {\n      acknowledged: ((_this$writeConcern = this.writeConcern) === null || _this$writeConcern === void 0 ? void 0 : _this$writeConcern.w) !== 0,\n      insertedId: this.documents[0]._id\n    };\n  }\n}\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\nclass InsertManyOperation extends operation_1.AbstractOperation {\n  constructor(collection, docs, options) {\n    super(options);\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n  get commandName() {\n    return 'insert';\n  }\n  async execute(server, session, timeoutContext) {\n    const coll = this.collection;\n    const options = _objectSpread(_objectSpread(_objectSpread({}, this.options), this.bsonOptions), {}, {\n      readPreference: this.readPreference\n    });\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, this.docs.map(document => ({\n      insertOne: {\n        document\n      }\n    })), options);\n    try {\n      const res = await bulkWriteOperation.execute(server, session, timeoutContext);\n      return {\n        acknowledged: (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      };\n    } catch (err) {\n      if (err && err.message === 'Operation must be an object with an operation key') {\n        throw new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');\n      }\n      throw err;\n    }\n  }\n}\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"names":["error_1","require","utils_1","write_concern_1","bulk_write_1","command_1","operation_1","InsertOperation","CommandOperation","constructor","ns","documents","options","_options$checkKeys","undefined","_objectSpread","checkKeys","commandName","execute","server","session","timeoutContext","_this$options","ordered","command","insert","collection","bypassDocumentValidation","comment","executeCommand","exports","InsertOneOperation","doc","s","namespace","maybeAddIdToDocuments","_this$writeConcern","res","code","MongoServerError","writeErrors","acknowledged","writeConcern","w","insertedId","_id","InsertManyOperation","AbstractOperation","docs","Array","isArray","MongoInvalidArgumentError","coll","bsonOptions","readPreference","WriteConcern","fromOptions","bulkWriteOperation","BulkWriteOperation","map","document","insertOne","insertedCount","insertedIds","err","message","defineAspects","Aspect","RETRYABLE","WRITE_OPERATION"],"sources":["/Users/glebch/workprojects/baumna/client/node_modules/mongodb/src/operations/insert.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { BulkWriteOptions } from '../bulk/common';\nimport type { Collection } from '../collection';\nimport { MongoInvalidArgumentError, MongoServerError } from '../error';\nimport type { InferIdType } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { maybeAddIdToDocuments, type MongoDBNamespace } from '../utils';\nimport { WriteConcern } from '../write_concern';\nimport { BulkWriteOperation } from './bulk_write';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\n\n/** @internal */\nexport class InsertOperation extends CommandOperation<Document> {\n  override options: BulkWriteOptions;\n  documents: Document[];\n\n  constructor(ns: MongoDBNamespace, documents: Document[], options: BulkWriteOptions) {\n    super(undefined, options);\n    this.options = { ...options, checkKeys: options.checkKeys ?? false };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  override get commandName() {\n    return 'insert' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command: Document = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    return await super.executeCommand(server, session, command, timeoutContext);\n  }\n}\n\n/** @public */\nexport interface InsertOneOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** Force server to assign _id values instead of driver. */\n  forceServerObjectId?: boolean;\n}\n\n/** @public */\nexport interface InsertOneResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\n  insertedId: InferIdType<TSchema>;\n}\n\nexport class InsertOneOperation extends InsertOperation {\n  constructor(collection: Collection, doc: Document, options: InsertOneOptions) {\n    super(collection.s.namespace, maybeAddIdToDocuments(collection, [doc], options), options);\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<InsertOneResult> {\n    const res = await super.execute(server, session, timeoutContext);\n    if (res.code) throw new MongoServerError(res);\n    if (res.writeErrors) {\n      // This should be a WriteError but we can't change it now because of error hierarchy\n      throw new MongoServerError(res.writeErrors[0]);\n    }\n\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      insertedId: this.documents[0]._id\n    };\n  }\n}\n\n/** @public */\nexport interface InsertManyResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of inserted documents for this operations */\n  insertedCount: number;\n  /** Map of the index of the inserted document to the id of the inserted document */\n  insertedIds: { [key: number]: InferIdType<TSchema> };\n}\n\n/** @internal */\nexport class InsertManyOperation extends AbstractOperation<InsertManyResult> {\n  override options: BulkWriteOptions;\n  collection: Collection;\n  docs: ReadonlyArray<Document>;\n\n  constructor(collection: Collection, docs: ReadonlyArray<Document>, options: BulkWriteOptions) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  override get commandName() {\n    return 'insert' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<InsertManyResult> {\n    const coll = this.collection;\n    const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\n    const writeConcern = WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new BulkWriteOperation(\n      coll,\n      this.docs.map(document => ({\n        insertOne: { document }\n      })),\n      options\n    );\n\n    try {\n      const res = await bulkWriteOperation.execute(server, session, timeoutContext);\n      return {\n        acknowledged: writeConcern?.w !== 0,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      };\n    } catch (err) {\n      if (err && err.message === 'Operation must be an object with an operation key') {\n        throw new MongoInvalidArgumentError(\n          'Collection.insertMany() cannot be called with an array that has null/undefined values'\n        );\n      }\n      throw err;\n    }\n  }\n}\n\ndefineAspects(InsertOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertOneOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertManyOperation, [Aspect.WRITE_OPERATION]);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}