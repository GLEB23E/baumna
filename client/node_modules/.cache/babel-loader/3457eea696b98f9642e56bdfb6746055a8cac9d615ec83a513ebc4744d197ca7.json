{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LegacyTimeoutContext = exports.CSOTTimeoutContext = exports.TimeoutContext = exports.Timeout = exports.TimeoutError = void 0;\nconst timers_1 = require(\"timers\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\n/** @internal */\nclass TimeoutError extends Error {\n  get name() {\n    return 'TimeoutError';\n  }\n  constructor(message, options) {\n    super(message, options);\n    this.duration = options.duration;\n  }\n  static is(error) {\n    return error != null && typeof error === 'object' && 'name' in error && error.name === 'TimeoutError';\n  }\n}\nexports.TimeoutError = TimeoutError;\n/**\n * @internal\n * This class is an abstraction over timeouts\n * The Timeout class can only be in the pending or rejected states. It is guaranteed not to resolve\n * if interacted with exclusively through its public API\n * */\nclass Timeout extends Promise {\n  get remainingTime() {\n    if (this.timedOut) return 0;\n    if (this.duration === 0) return Infinity;\n    return this.start + this.duration - Math.trunc(performance.now());\n  }\n  get timeElapsed() {\n    return Math.trunc(performance.now()) - this.start;\n  }\n  /** Create a new timeout that expires in `duration` ms */\n  constructor() {\n    var _options$duration;\n    let executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => null;\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    const duration = (_options$duration = options === null || options === void 0 ? void 0 : options.duration) !== null && _options$duration !== void 0 ? _options$duration : 0;\n    const unref = !!(options !== null && options !== void 0 && options.unref);\n    const rejection = options === null || options === void 0 ? void 0 : options.rejection;\n    if (duration < 0) {\n      throw new error_1.MongoInvalidArgumentError('Cannot create a Timeout with a negative duration');\n    }\n    let reject;\n    super((_, promiseReject) => {\n      reject = promiseReject;\n      executor(utils_1.noop, promiseReject);\n    });\n    this.ended = null;\n    this.timedOut = false;\n    this.cleared = false;\n    this.duration = duration;\n    this.start = Math.trunc(performance.now());\n    if (rejection == null && this.duration > 0) {\n      this.id = (0, timers_1.setTimeout)(() => {\n        this.ended = Math.trunc(performance.now());\n        this.timedOut = true;\n        reject(new TimeoutError(\"Expired after \".concat(duration, \"ms\"), {\n          duration\n        }));\n      }, this.duration);\n      if (typeof this.id.unref === 'function' && unref) {\n        // Ensure we do not keep the Node.js event loop running\n        this.id.unref();\n      }\n    } else if (rejection != null) {\n      this.ended = Math.trunc(performance.now());\n      this.timedOut = true;\n      reject(rejection);\n    }\n  }\n  /**\n   * Clears the underlying timeout. This method is idempotent\n   */\n  clear() {\n    (0, timers_1.clearTimeout)(this.id);\n    this.id = undefined;\n    this.timedOut = false;\n    this.cleared = true;\n  }\n  throwIfExpired() {\n    if (this.timedOut) throw new TimeoutError('Timed out', {\n      duration: this.duration\n    });\n  }\n  static expires(duration, unref) {\n    return new Timeout(undefined, {\n      duration,\n      unref\n    });\n  }\n  static reject(rejection) {\n    return new Timeout(undefined, {\n      duration: 0,\n      unref: true,\n      rejection\n    });\n  }\n}\nexports.Timeout = Timeout;\nfunction isLegacyTimeoutContextOptions(v) {\n  return v != null && typeof v === 'object' && 'serverSelectionTimeoutMS' in v && typeof v.serverSelectionTimeoutMS === 'number' && 'waitQueueTimeoutMS' in v && typeof v.waitQueueTimeoutMS === 'number';\n}\nfunction isCSOTTimeoutContextOptions(v) {\n  return v != null && typeof v === 'object' && 'serverSelectionTimeoutMS' in v && typeof v.serverSelectionTimeoutMS === 'number' && 'timeoutMS' in v && typeof v.timeoutMS === 'number';\n}\n/** @internal */\nclass TimeoutContext {\n  static create(options) {\n    var _options$session, _options$session2;\n    if (((_options$session = options.session) === null || _options$session === void 0 ? void 0 : _options$session.timeoutContext) != null) return (_options$session2 = options.session) === null || _options$session2 === void 0 ? void 0 : _options$session2.timeoutContext;\n    if (isCSOTTimeoutContextOptions(options)) return new CSOTTimeoutContext(options);else if (isLegacyTimeoutContextOptions(options)) return new LegacyTimeoutContext(options);else throw new error_1.MongoRuntimeError('Unrecognized options');\n  }\n}\nexports.TimeoutContext = TimeoutContext;\n/** @internal */\nclass CSOTTimeoutContext extends TimeoutContext {\n  constructor(options) {\n    super();\n    this.minRoundTripTime = 0;\n    this.start = Math.trunc(performance.now());\n    this.timeoutMS = options.timeoutMS;\n    this.serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n    this.socketTimeoutMS = options.socketTimeoutMS;\n    this.clearServerSelectionTimeout = false;\n  }\n  get maxTimeMS() {\n    return this.remainingTimeMS - this.minRoundTripTime;\n  }\n  get remainingTimeMS() {\n    const timePassed = Math.trunc(performance.now()) - this.start;\n    return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;\n  }\n  csotEnabled() {\n    return true;\n  }\n  get serverSelectionTimeout() {\n    var _this$_serverSelectio;\n    // check for undefined\n    if (typeof this._serverSelectionTimeout !== 'object' || (_this$_serverSelectio = this._serverSelectionTimeout) !== null && _this$_serverSelectio !== void 0 && _this$_serverSelectio.cleared) {\n      const {\n        remainingTimeMS,\n        serverSelectionTimeoutMS\n      } = this;\n      if (remainingTimeMS <= 0) return Timeout.reject(new error_1.MongoOperationTimeoutError(\"Timed out in server selection after \".concat(this.timeoutMS, \"ms\")));\n      const usingServerSelectionTimeoutMS = serverSelectionTimeoutMS !== 0 && (0, utils_1.csotMin)(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;\n      if (usingServerSelectionTimeoutMS) {\n        this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);\n      } else {\n        if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {\n          this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);\n        } else {\n          this._serverSelectionTimeout = null;\n        }\n      }\n    }\n    return this._serverSelectionTimeout;\n  }\n  get connectionCheckoutTimeout() {\n    var _this$_connectionChec;\n    if (typeof this._connectionCheckoutTimeout !== 'object' || (_this$_connectionChec = this._connectionCheckoutTimeout) !== null && _this$_connectionChec !== void 0 && _this$_connectionChec.cleared) {\n      if (typeof this._serverSelectionTimeout === 'object') {\n        // null or Timeout\n        this._connectionCheckoutTimeout = this._serverSelectionTimeout;\n      } else {\n        throw new error_1.MongoRuntimeError('Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira');\n      }\n    }\n    return this._connectionCheckoutTimeout;\n  }\n  get timeoutForSocketWrite() {\n    const {\n      remainingTimeMS\n    } = this;\n    if (!Number.isFinite(remainingTimeMS)) return null;\n    if (remainingTimeMS > 0) return Timeout.expires(remainingTimeMS);\n    return Timeout.reject(new error_1.MongoOperationTimeoutError('Timed out before socket write'));\n  }\n  get timeoutForSocketRead() {\n    const {\n      remainingTimeMS\n    } = this;\n    if (!Number.isFinite(remainingTimeMS)) return null;\n    if (remainingTimeMS > 0) return Timeout.expires(remainingTimeMS);\n    return Timeout.reject(new error_1.MongoOperationTimeoutError('Timed out before socket read'));\n  }\n  refresh() {\n    var _this$_serverSelectio2, _this$_connectionChec2;\n    this.start = Math.trunc(performance.now());\n    this.minRoundTripTime = 0;\n    (_this$_serverSelectio2 = this._serverSelectionTimeout) === null || _this$_serverSelectio2 === void 0 || _this$_serverSelectio2.clear();\n    (_this$_connectionChec2 = this._connectionCheckoutTimeout) === null || _this$_connectionChec2 === void 0 || _this$_connectionChec2.clear();\n  }\n  clear() {\n    var _this$_serverSelectio3, _this$_connectionChec3;\n    (_this$_serverSelectio3 = this._serverSelectionTimeout) === null || _this$_serverSelectio3 === void 0 || _this$_serverSelectio3.clear();\n    (_this$_connectionChec3 = this._connectionCheckoutTimeout) === null || _this$_connectionChec3 === void 0 || _this$_connectionChec3.clear();\n  }\n  /**\n   * @internal\n   * Throws a MongoOperationTimeoutError if the context has expired.\n   * If the context has not expired, returns the `remainingTimeMS`\n   **/\n  getRemainingTimeMSOrThrow(message) {\n    const {\n      remainingTimeMS\n    } = this;\n    if (remainingTimeMS <= 0) throw new error_1.MongoOperationTimeoutError(message !== null && message !== void 0 ? message : \"Expired after \".concat(this.timeoutMS, \"ms\"));\n    return remainingTimeMS;\n  }\n  /**\n   * @internal\n   * This method is intended to be used in situations where concurrent operation are on the same deadline, but cannot share a single `TimeoutContext` instance.\n   * Returns a new instance of `CSOTTimeoutContext` constructed with identical options, but setting the `start` property to `this.start`.\n   */\n  clone() {\n    const timeoutContext = new CSOTTimeoutContext({\n      timeoutMS: this.timeoutMS,\n      serverSelectionTimeoutMS: this.serverSelectionTimeoutMS\n    });\n    timeoutContext.start = this.start;\n    return timeoutContext;\n  }\n  refreshed() {\n    return new CSOTTimeoutContext(this);\n  }\n  addMaxTimeMSToCommand(command, options) {\n    if (options.omitMaxTimeMS) return;\n    const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;\n    if (maxTimeMS > 0 && Number.isFinite(maxTimeMS)) command.maxTimeMS = maxTimeMS;\n  }\n  getSocketTimeoutMS() {\n    return 0;\n  }\n}\nexports.CSOTTimeoutContext = CSOTTimeoutContext;\n/** @internal */\nclass LegacyTimeoutContext extends TimeoutContext {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.clearServerSelectionTimeout = true;\n  }\n  csotEnabled() {\n    return false;\n  }\n  get serverSelectionTimeout() {\n    if (this.options.serverSelectionTimeoutMS != null && this.options.serverSelectionTimeoutMS > 0) return Timeout.expires(this.options.serverSelectionTimeoutMS);\n    return null;\n  }\n  get connectionCheckoutTimeout() {\n    if (this.options.waitQueueTimeoutMS != null && this.options.waitQueueTimeoutMS > 0) return Timeout.expires(this.options.waitQueueTimeoutMS);\n    return null;\n  }\n  get timeoutForSocketWrite() {\n    return null;\n  }\n  get timeoutForSocketRead() {\n    return null;\n  }\n  refresh() {\n    return;\n  }\n  clear() {\n    return;\n  }\n  get maxTimeMS() {\n    return null;\n  }\n  refreshed() {\n    return new LegacyTimeoutContext(this.options);\n  }\n  addMaxTimeMSToCommand(_command, _options) {\n    // No max timeMS is added to commands in legacy timeout mode.\n  }\n  getSocketTimeoutMS() {\n    return this.options.socketTimeoutMS;\n  }\n}\nexports.LegacyTimeoutContext = LegacyTimeoutContext;","map":{"version":3,"names":["timers_1","require","error_1","utils_1","TimeoutError","Error","name","constructor","message","options","duration","is","error","exports","Timeout","Promise","remainingTime","timedOut","Infinity","start","Math","trunc","performance","now","timeElapsed","_options$duration","executor","arguments","length","undefined","unref","rejection","MongoInvalidArgumentError","reject","_","promiseReject","noop","ended","cleared","id","setTimeout","concat","clear","clearTimeout","throwIfExpired","expires","isLegacyTimeoutContextOptions","v","serverSelectionTimeoutMS","waitQueueTimeoutMS","isCSOTTimeoutContextOptions","timeoutMS","TimeoutContext","create","_options$session","_options$session2","session","timeoutContext","CSOTTimeoutContext","LegacyTimeoutContext","MongoRuntimeError","minRoundTripTime","socketTimeoutMS","clearServerSelectionTimeout","maxTimeMS","remainingTimeMS","timePassed","csotEnabled","serverSelectionTimeout","_this$_serverSelectio","_serverSelectionTimeout","MongoOperationTimeoutError","usingServerSelectionTimeoutMS","csotMin","Number","isFinite","connectionCheckoutTimeout","_this$_connectionChec","_connectionCheckoutTimeout","timeoutForSocketWrite","timeoutForSocketRead","refresh","_this$_serverSelectio2","_this$_connectionChec2","_this$_serverSelectio3","_this$_connectionChec3","getRemainingTimeMSOrThrow","clone","refreshed","addMaxTimeMSToCommand","command","omitMaxTimeMS","getSocketTimeoutMS","_command","_options"],"sources":["/Users/glebch/workprojects/baumna/client/node_modules/mongodb/src/timeout.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\n\nimport { type Document } from './bson';\nimport { MongoInvalidArgumentError, MongoOperationTimeoutError, MongoRuntimeError } from './error';\nimport { type ClientSession } from './sessions';\nimport { csotMin, noop } from './utils';\n\n/** @internal */\nexport class TimeoutError extends Error {\n  duration: number;\n  override get name(): 'TimeoutError' {\n    return 'TimeoutError';\n  }\n\n  constructor(message: string, options: { cause?: Error; duration: number }) {\n    super(message, options);\n    this.duration = options.duration;\n  }\n\n  static is(error: unknown): error is TimeoutError {\n    return (\n      error != null && typeof error === 'object' && 'name' in error && error.name === 'TimeoutError'\n    );\n  }\n}\n\ntype Executor = ConstructorParameters<typeof Promise<never>>[0];\ntype Reject = Parameters<ConstructorParameters<typeof Promise<never>>[0]>[1];\n/**\n * @internal\n * This class is an abstraction over timeouts\n * The Timeout class can only be in the pending or rejected states. It is guaranteed not to resolve\n * if interacted with exclusively through its public API\n * */\nexport class Timeout extends Promise<never> {\n  private id?: NodeJS.Timeout;\n\n  public readonly start: number;\n  public ended: number | null = null;\n  public duration: number;\n  private timedOut = false;\n  public cleared = false;\n\n  get remainingTime(): number {\n    if (this.timedOut) return 0;\n    if (this.duration === 0) return Infinity;\n    return this.start + this.duration - Math.trunc(performance.now());\n  }\n\n  get timeElapsed(): number {\n    return Math.trunc(performance.now()) - this.start;\n  }\n\n  /** Create a new timeout that expires in `duration` ms */\n  private constructor(\n    executor: Executor = () => null,\n    options?: { duration: number; unref?: true; rejection?: Error }\n  ) {\n    const duration = options?.duration ?? 0;\n    const unref = !!options?.unref;\n    const rejection = options?.rejection;\n\n    if (duration < 0) {\n      throw new MongoInvalidArgumentError('Cannot create a Timeout with a negative duration');\n    }\n\n    let reject!: Reject;\n    super((_, promiseReject) => {\n      reject = promiseReject;\n\n      executor(noop, promiseReject);\n    });\n\n    this.duration = duration;\n    this.start = Math.trunc(performance.now());\n\n    if (rejection == null && this.duration > 0) {\n      this.id = setTimeout(() => {\n        this.ended = Math.trunc(performance.now());\n        this.timedOut = true;\n        reject(new TimeoutError(`Expired after ${duration}ms`, { duration }));\n      }, this.duration);\n      if (typeof this.id.unref === 'function' && unref) {\n        // Ensure we do not keep the Node.js event loop running\n        this.id.unref();\n      }\n    } else if (rejection != null) {\n      this.ended = Math.trunc(performance.now());\n      this.timedOut = true;\n      reject(rejection);\n    }\n  }\n\n  /**\n   * Clears the underlying timeout. This method is idempotent\n   */\n  clear(): void {\n    clearTimeout(this.id);\n    this.id = undefined;\n    this.timedOut = false;\n    this.cleared = true;\n  }\n\n  throwIfExpired(): void {\n    if (this.timedOut) throw new TimeoutError('Timed out', { duration: this.duration });\n  }\n\n  public static expires(duration: number, unref?: true): Timeout {\n    return new Timeout(undefined, { duration, unref });\n  }\n\n  static override reject(rejection?: Error): Timeout {\n    return new Timeout(undefined, { duration: 0, unref: true, rejection });\n  }\n}\n\n/** @internal */\nexport type TimeoutContextOptions = (LegacyTimeoutContextOptions | CSOTTimeoutContextOptions) & {\n  session?: ClientSession;\n};\n\n/** @internal */\nexport type LegacyTimeoutContextOptions = {\n  serverSelectionTimeoutMS: number;\n  waitQueueTimeoutMS: number;\n  socketTimeoutMS?: number;\n};\n\n/** @internal */\nexport type CSOTTimeoutContextOptions = {\n  timeoutMS: number;\n  serverSelectionTimeoutMS: number;\n  socketTimeoutMS?: number;\n};\n\nfunction isLegacyTimeoutContextOptions(v: unknown): v is LegacyTimeoutContextOptions {\n  return (\n    v != null &&\n    typeof v === 'object' &&\n    'serverSelectionTimeoutMS' in v &&\n    typeof v.serverSelectionTimeoutMS === 'number' &&\n    'waitQueueTimeoutMS' in v &&\n    typeof v.waitQueueTimeoutMS === 'number'\n  );\n}\n\nfunction isCSOTTimeoutContextOptions(v: unknown): v is CSOTTimeoutContextOptions {\n  return (\n    v != null &&\n    typeof v === 'object' &&\n    'serverSelectionTimeoutMS' in v &&\n    typeof v.serverSelectionTimeoutMS === 'number' &&\n    'timeoutMS' in v &&\n    typeof v.timeoutMS === 'number'\n  );\n}\n\n/** @internal */\nexport abstract class TimeoutContext {\n  static create(options: TimeoutContextOptions): TimeoutContext {\n    if (options.session?.timeoutContext != null) return options.session?.timeoutContext;\n    if (isCSOTTimeoutContextOptions(options)) return new CSOTTimeoutContext(options);\n    else if (isLegacyTimeoutContextOptions(options)) return new LegacyTimeoutContext(options);\n    else throw new MongoRuntimeError('Unrecognized options');\n  }\n\n  abstract get maxTimeMS(): number | null;\n\n  abstract get serverSelectionTimeout(): Timeout | null;\n\n  abstract get connectionCheckoutTimeout(): Timeout | null;\n\n  abstract get clearServerSelectionTimeout(): boolean;\n\n  abstract get timeoutForSocketWrite(): Timeout | null;\n\n  abstract get timeoutForSocketRead(): Timeout | null;\n\n  abstract csotEnabled(): this is CSOTTimeoutContext;\n\n  abstract refresh(): void;\n\n  abstract clear(): void;\n\n  /** Returns a new instance of the TimeoutContext, with all timeouts refreshed and restarted. */\n  abstract refreshed(): TimeoutContext;\n\n  abstract addMaxTimeMSToCommand(command: Document, options: { omitMaxTimeMS?: boolean }): void;\n\n  abstract getSocketTimeoutMS(): number | undefined;\n}\n\n/** @internal */\nexport class CSOTTimeoutContext extends TimeoutContext {\n  timeoutMS: number;\n  serverSelectionTimeoutMS: number;\n  socketTimeoutMS?: number;\n\n  clearServerSelectionTimeout: boolean;\n\n  private _serverSelectionTimeout?: Timeout | null;\n  private _connectionCheckoutTimeout?: Timeout | null;\n  public minRoundTripTime = 0;\n  public start: number;\n\n  constructor(options: CSOTTimeoutContextOptions) {\n    super();\n    this.start = Math.trunc(performance.now());\n\n    this.timeoutMS = options.timeoutMS;\n\n    this.serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n\n    this.socketTimeoutMS = options.socketTimeoutMS;\n\n    this.clearServerSelectionTimeout = false;\n  }\n\n  get maxTimeMS(): number {\n    return this.remainingTimeMS - this.minRoundTripTime;\n  }\n\n  get remainingTimeMS() {\n    const timePassed = Math.trunc(performance.now()) - this.start;\n    return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;\n  }\n\n  csotEnabled(): this is CSOTTimeoutContext {\n    return true;\n  }\n\n  get serverSelectionTimeout(): Timeout | null {\n    // check for undefined\n    if (typeof this._serverSelectionTimeout !== 'object' || this._serverSelectionTimeout?.cleared) {\n      const { remainingTimeMS, serverSelectionTimeoutMS } = this;\n      if (remainingTimeMS <= 0)\n        return Timeout.reject(\n          new MongoOperationTimeoutError(`Timed out in server selection after ${this.timeoutMS}ms`)\n        );\n      const usingServerSelectionTimeoutMS =\n        serverSelectionTimeoutMS !== 0 &&\n        csotMin(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;\n      if (usingServerSelectionTimeoutMS) {\n        this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);\n      } else {\n        if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {\n          this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);\n        } else {\n          this._serverSelectionTimeout = null;\n        }\n      }\n    }\n\n    return this._serverSelectionTimeout;\n  }\n\n  get connectionCheckoutTimeout(): Timeout | null {\n    if (\n      typeof this._connectionCheckoutTimeout !== 'object' ||\n      this._connectionCheckoutTimeout?.cleared\n    ) {\n      if (typeof this._serverSelectionTimeout === 'object') {\n        // null or Timeout\n        this._connectionCheckoutTimeout = this._serverSelectionTimeout;\n      } else {\n        throw new MongoRuntimeError(\n          'Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira'\n        );\n      }\n    }\n    return this._connectionCheckoutTimeout;\n  }\n\n  get timeoutForSocketWrite(): Timeout | null {\n    const { remainingTimeMS } = this;\n    if (!Number.isFinite(remainingTimeMS)) return null;\n    if (remainingTimeMS > 0) return Timeout.expires(remainingTimeMS);\n    return Timeout.reject(new MongoOperationTimeoutError('Timed out before socket write'));\n  }\n\n  get timeoutForSocketRead(): Timeout | null {\n    const { remainingTimeMS } = this;\n    if (!Number.isFinite(remainingTimeMS)) return null;\n    if (remainingTimeMS > 0) return Timeout.expires(remainingTimeMS);\n    return Timeout.reject(new MongoOperationTimeoutError('Timed out before socket read'));\n  }\n\n  refresh(): void {\n    this.start = Math.trunc(performance.now());\n    this.minRoundTripTime = 0;\n    this._serverSelectionTimeout?.clear();\n    this._connectionCheckoutTimeout?.clear();\n  }\n\n  clear(): void {\n    this._serverSelectionTimeout?.clear();\n    this._connectionCheckoutTimeout?.clear();\n  }\n\n  /**\n   * @internal\n   * Throws a MongoOperationTimeoutError if the context has expired.\n   * If the context has not expired, returns the `remainingTimeMS`\n   **/\n  getRemainingTimeMSOrThrow(message?: string): number {\n    const { remainingTimeMS } = this;\n    if (remainingTimeMS <= 0)\n      throw new MongoOperationTimeoutError(message ?? `Expired after ${this.timeoutMS}ms`);\n    return remainingTimeMS;\n  }\n\n  /**\n   * @internal\n   * This method is intended to be used in situations where concurrent operation are on the same deadline, but cannot share a single `TimeoutContext` instance.\n   * Returns a new instance of `CSOTTimeoutContext` constructed with identical options, but setting the `start` property to `this.start`.\n   */\n  clone(): CSOTTimeoutContext {\n    const timeoutContext = new CSOTTimeoutContext({\n      timeoutMS: this.timeoutMS,\n      serverSelectionTimeoutMS: this.serverSelectionTimeoutMS\n    });\n    timeoutContext.start = this.start;\n    return timeoutContext;\n  }\n\n  override refreshed(): CSOTTimeoutContext {\n    return new CSOTTimeoutContext(this);\n  }\n\n  override addMaxTimeMSToCommand(command: Document, options: { omitMaxTimeMS?: boolean }): void {\n    if (options.omitMaxTimeMS) return;\n    const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;\n    if (maxTimeMS > 0 && Number.isFinite(maxTimeMS)) command.maxTimeMS = maxTimeMS;\n  }\n\n  override getSocketTimeoutMS(): number | undefined {\n    return 0;\n  }\n}\n\n/** @internal */\nexport class LegacyTimeoutContext extends TimeoutContext {\n  options: LegacyTimeoutContextOptions;\n  clearServerSelectionTimeout: boolean;\n\n  constructor(options: LegacyTimeoutContextOptions) {\n    super();\n    this.options = options;\n    this.clearServerSelectionTimeout = true;\n  }\n\n  csotEnabled(): this is CSOTTimeoutContext {\n    return false;\n  }\n\n  get serverSelectionTimeout(): Timeout | null {\n    if (this.options.serverSelectionTimeoutMS != null && this.options.serverSelectionTimeoutMS > 0)\n      return Timeout.expires(this.options.serverSelectionTimeoutMS);\n    return null;\n  }\n\n  get connectionCheckoutTimeout(): Timeout | null {\n    if (this.options.waitQueueTimeoutMS != null && this.options.waitQueueTimeoutMS > 0)\n      return Timeout.expires(this.options.waitQueueTimeoutMS);\n    return null;\n  }\n\n  get timeoutForSocketWrite(): Timeout | null {\n    return null;\n  }\n\n  get timeoutForSocketRead(): Timeout | null {\n    return null;\n  }\n\n  refresh(): void {\n    return;\n  }\n\n  clear(): void {\n    return;\n  }\n\n  get maxTimeMS() {\n    return null;\n  }\n\n  override refreshed(): LegacyTimeoutContext {\n    return new LegacyTimeoutContext(this.options);\n  }\n\n  override addMaxTimeMSToCommand(_command: Document, _options: { omitMaxTimeMS?: boolean }): void {\n    // No max timeMS is added to commands in legacy timeout mode.\n  }\n\n  override getSocketTimeoutMS(): number | undefined {\n    return this.options.socketTimeoutMS;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}