{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/glebch/workprojects/baumna/client/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucket = void 0;\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"../write_concern\");\nconst download_1 = require(\"./download\");\nconst upload_1 = require(\"./upload\");\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n  constructor(db, options) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = (0, utils_1.resolveOptions)(db, _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_GRIDFS_BUCKET_OPTIONS), options), {}, {\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    }));\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n  openUploadStream(filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, _objectSpread({\n      timeoutMS: this.s.options.timeoutMS\n    }, options));\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n  openUploadStreamWithId(id, filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, _objectSpread(_objectSpread({\n      timeoutMS: this.s.options.timeoutMS\n    }, options), {}, {\n      id\n    }));\n  }\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n  openDownloadStream(id, options) {\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      _id: id\n    }, _objectSpread({\n      timeoutMS: this.s.options.timeoutMS\n    }, options));\n  }\n  /**\n   * Deletes a file with the given id\n   *\n   * @param id - The id of the file doc\n   */\n  async delete(id, options) {\n    var _timeoutContext, _timeoutContext2;\n    const {\n      timeoutMS\n    } = (0, utils_1.resolveOptions)(this.s.db, options);\n    let timeoutContext = undefined;\n    if (timeoutMS) {\n      timeoutContext = new timeout_1.CSOTTimeoutContext({\n        timeoutMS,\n        serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS\n      });\n    }\n    const {\n      deletedCount\n    } = await this.s._filesCollection.deleteOne({\n      _id: id\n    }, {\n      timeoutMS: (_timeoutContext = timeoutContext) === null || _timeoutContext === void 0 ? void 0 : _timeoutContext.remainingTimeMS\n    });\n    const remainingTimeMS = (_timeoutContext2 = timeoutContext) === null || _timeoutContext2 === void 0 ? void 0 : _timeoutContext2.remainingTimeMS;\n    if (remainingTimeMS != null && remainingTimeMS <= 0) throw new error_1.MongoOperationTimeoutError(\"Timed out after \".concat(timeoutMS, \"ms\"));\n    // Delete orphaned chunks before returning FileNotFound\n    await this.s._chunksCollection.deleteMany({\n      files_id: id\n    }, {\n      timeoutMS: remainingTimeMS\n    });\n    if (deletedCount === 0) {\n      // TODO(NODE-3483): Replace with more appropriate error\n      // Consider creating new error MongoGridFSFileNotFoundError\n      throw new error_1.MongoRuntimeError(\"File not found for id \".concat(id));\n    }\n  }\n  /** Convenience wrapper around find on the files collection */\n  find() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.s._filesCollection.find(filter, options);\n  }\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n  openDownloadStreamByName(filename, options) {\n    let sort = {\n      uploadDate: -1\n    };\n    let skip = undefined;\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = {\n          uploadDate: 1\n        };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      filename\n    }, _objectSpread(_objectSpread({\n      timeoutMS: this.s.options.timeoutMS\n    }, options), {}, {\n      sort,\n      skip\n    }));\n  }\n  /**\n   * Renames the file with the given _id to the given string\n   *\n   * @param id - the id of the file to rename\n   * @param filename - new name for the file\n   */\n  async rename(id, filename, options) {\n    const filter = {\n      _id: id\n    };\n    const update = {\n      $set: {\n        filename\n      }\n    };\n    const {\n      matchedCount\n    } = await this.s._filesCollection.updateOne(filter, update, options);\n    if (matchedCount === 0) {\n      throw new error_1.MongoRuntimeError(\"File with id \".concat(id, \" not found\"));\n    }\n  }\n  /** Removes this bucket's files collection, followed by its chunks collection. */\n  async drop(options) {\n    const {\n      timeoutMS\n    } = (0, utils_1.resolveOptions)(this.s.db, options);\n    let timeoutContext = undefined;\n    if (timeoutMS) {\n      timeoutContext = new timeout_1.CSOTTimeoutContext({\n        timeoutMS,\n        serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS\n      });\n    }\n    if (timeoutContext) {\n      await this.s._filesCollection.drop({\n        timeoutMS: timeoutContext.remainingTimeMS\n      });\n      const remainingTimeMS = timeoutContext.getRemainingTimeMSOrThrow(\"Timed out after \".concat(timeoutMS, \"ms\"));\n      await this.s._chunksCollection.drop({\n        timeoutMS: remainingTimeMS\n      });\n    } else {\n      await this.s._filesCollection.drop();\n      await this.s._chunksCollection.drop();\n    }\n  }\n}\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\nGridFSBucket.INDEX = 'index';","map":{"version":3,"names":["error_1","require","mongo_types_1","timeout_1","utils_1","write_concern_1","download_1","upload_1","DEFAULT_GRIDFS_BUCKET_OPTIONS","bucketName","chunkSizeBytes","GridFSBucket","TypedEventEmitter","constructor","db","options","setMaxListeners","privateOptions","resolveOptions","_objectSpread","writeConcern","WriteConcern","fromOptions","s","_chunksCollection","collection","_filesCollection","checkedIndexes","calledOpenUploadStream","openUploadStream","filename","GridFSBucketWriteStream","timeoutMS","openUploadStreamWithId","id","openDownloadStream","GridFSBucketReadStream","readPreference","_id","delete","_timeoutContext","_timeoutContext2","timeoutContext","undefined","CSOTTimeoutContext","serverSelectionTimeoutMS","client","deletedCount","deleteOne","remainingTimeMS","MongoOperationTimeoutError","concat","deleteMany","files_id","MongoRuntimeError","find","filter","arguments","length","openDownloadStreamByName","sort","uploadDate","skip","revision","rename","update","$set","matchedCount","updateOne","drop","getRemainingTimeMSOrThrow","exports","INDEX"],"sources":["/Users/glebch/workprojects/baumna/client/node_modules/mongodb/src/gridfs/index.ts"],"sourcesContent":["import type { ObjectId } from '../bson';\nimport type { Collection } from '../collection';\nimport type { FindCursor } from '../cursor/find_cursor';\nimport type { Db } from '../db';\nimport { MongoOperationTimeoutError, MongoRuntimeError } from '../error';\nimport { type Filter, TypedEventEmitter } from '../mongo_types';\nimport type { ReadPreference } from '../read_preference';\nimport type { Sort } from '../sort';\nimport { CSOTTimeoutContext } from '../timeout';\nimport { resolveOptions } from '../utils';\nimport { WriteConcern, type WriteConcernOptions } from '../write_concern';\nimport type { FindOptions } from './../operations/find';\nimport {\n  GridFSBucketReadStream,\n  type GridFSBucketReadStreamOptions,\n  type GridFSBucketReadStreamOptionsWithRevision,\n  type GridFSFile\n} from './download';\nimport {\n  GridFSBucketWriteStream,\n  type GridFSBucketWriteStreamOptions,\n  type GridFSChunk\n} from './upload';\n\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS: {\n  bucketName: string;\n  chunkSizeBytes: number;\n} = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n\n/** @public */\nexport interface GridFSBucketOptions extends WriteConcernOptions {\n  /** The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot. */\n  bucketName?: string;\n  /** Number of bytes stored in each chunk. Defaults to 255KB */\n  chunkSizeBytes?: number;\n  /** Read preference to be passed to read operations */\n  readPreference?: ReadPreference;\n  /**\n   * @experimental\n   * Specifies the lifetime duration of a gridFS stream. If any async operations are in progress\n   * when this timeout expires, the stream will throw a timeout error.\n   */\n  timeoutMS?: number;\n}\n\n/** @internal */\nexport interface GridFSBucketPrivate {\n  db: Db;\n  options: {\n    bucketName: string;\n    chunkSizeBytes: number;\n    readPreference?: ReadPreference;\n    writeConcern: WriteConcern | undefined;\n    timeoutMS?: number;\n  };\n  _chunksCollection: Collection<GridFSChunk>;\n  _filesCollection: Collection<GridFSFile>;\n  checkedIndexes: boolean;\n  calledOpenUploadStream: boolean;\n}\n\n/** @public */\nexport type GridFSBucketEvents = {\n  index(): void;\n};\n\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nexport class GridFSBucket extends TypedEventEmitter<GridFSBucketEvents> {\n  /** @internal */\n  s: GridFSBucketPrivate;\n\n  /**\n   * When the first call to openUploadStream is made, the upload stream will\n   * check to see if it needs to create the proper indexes on the chunks and\n   * files collections. This event is fired either when 1) it determines that\n   * no index creation is necessary, 2) when it successfully creates the\n   * necessary indexes.\n   * @event\n   */\n  static readonly INDEX = 'index' as const;\n\n  constructor(db: Db, options?: GridFSBucketOptions) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = resolveOptions(db, {\n      ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: WriteConcern.fromOptions(options)\n    });\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection<GridFSChunk>(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection<GridFSFile>(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n\n  openUploadStream(\n    filename: string,\n    options?: GridFSBucketWriteStreamOptions\n  ): GridFSBucketWriteStream {\n    return new GridFSBucketWriteStream(this, filename, {\n      timeoutMS: this.s.options.timeoutMS,\n      ...options\n    });\n  }\n\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n  openUploadStreamWithId(\n    id: ObjectId,\n    filename: string,\n    options?: GridFSBucketWriteStreamOptions\n  ): GridFSBucketWriteStream {\n    return new GridFSBucketWriteStream(this, filename, {\n      timeoutMS: this.s.options.timeoutMS,\n      ...options,\n      id\n    });\n  }\n\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n  openDownloadStream(\n    id: ObjectId,\n    options?: GridFSBucketReadStreamOptions\n  ): GridFSBucketReadStream {\n    return new GridFSBucketReadStream(\n      this.s._chunksCollection,\n      this.s._filesCollection,\n      this.s.options.readPreference,\n      { _id: id },\n      { timeoutMS: this.s.options.timeoutMS, ...options }\n    );\n  }\n\n  /**\n   * Deletes a file with the given id\n   *\n   * @param id - The id of the file doc\n   */\n  async delete(id: ObjectId, options?: { timeoutMS: number }): Promise<void> {\n    const { timeoutMS } = resolveOptions(this.s.db, options);\n    let timeoutContext: CSOTTimeoutContext | undefined = undefined;\n\n    if (timeoutMS) {\n      timeoutContext = new CSOTTimeoutContext({\n        timeoutMS,\n        serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS\n      });\n    }\n\n    const { deletedCount } = await this.s._filesCollection.deleteOne(\n      { _id: id },\n      { timeoutMS: timeoutContext?.remainingTimeMS }\n    );\n\n    const remainingTimeMS = timeoutContext?.remainingTimeMS;\n    if (remainingTimeMS != null && remainingTimeMS <= 0)\n      throw new MongoOperationTimeoutError(`Timed out after ${timeoutMS}ms`);\n    // Delete orphaned chunks before returning FileNotFound\n    await this.s._chunksCollection.deleteMany({ files_id: id }, { timeoutMS: remainingTimeMS });\n\n    if (deletedCount === 0) {\n      // TODO(NODE-3483): Replace with more appropriate error\n      // Consider creating new error MongoGridFSFileNotFoundError\n      throw new MongoRuntimeError(`File not found for id ${id}`);\n    }\n  }\n\n  /** Convenience wrapper around find on the files collection */\n  find(filter: Filter<GridFSFile> = {}, options: FindOptions = {}): FindCursor<GridFSFile> {\n    return this.s._filesCollection.find(filter, options);\n  }\n\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n  openDownloadStreamByName(\n    filename: string,\n    options?: GridFSBucketReadStreamOptionsWithRevision\n  ): GridFSBucketReadStream {\n    let sort: Sort = { uploadDate: -1 };\n    let skip = undefined;\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = { uploadDate: 1 };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n    return new GridFSBucketReadStream(\n      this.s._chunksCollection,\n      this.s._filesCollection,\n      this.s.options.readPreference,\n      { filename },\n      { timeoutMS: this.s.options.timeoutMS, ...options, sort, skip }\n    );\n  }\n\n  /**\n   * Renames the file with the given _id to the given string\n   *\n   * @param id - the id of the file to rename\n   * @param filename - new name for the file\n   */\n  async rename(id: ObjectId, filename: string, options?: { timeoutMS: number }): Promise<void> {\n    const filter = { _id: id };\n    const update = { $set: { filename } };\n    const { matchedCount } = await this.s._filesCollection.updateOne(filter, update, options);\n    if (matchedCount === 0) {\n      throw new MongoRuntimeError(`File with id ${id} not found`);\n    }\n  }\n\n  /** Removes this bucket's files collection, followed by its chunks collection. */\n  async drop(options?: { timeoutMS: number }): Promise<void> {\n    const { timeoutMS } = resolveOptions(this.s.db, options);\n    let timeoutContext: CSOTTimeoutContext | undefined = undefined;\n\n    if (timeoutMS) {\n      timeoutContext = new CSOTTimeoutContext({\n        timeoutMS,\n        serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS\n      });\n    }\n\n    if (timeoutContext) {\n      await this.s._filesCollection.drop({ timeoutMS: timeoutContext.remainingTimeMS });\n      const remainingTimeMS = timeoutContext.getRemainingTimeMSOrThrow(\n        `Timed out after ${timeoutMS}ms`\n      );\n      await this.s._chunksCollection.drop({ timeoutMS: remainingTimeMS });\n    } else {\n      await this.s._filesCollection.drop();\n      await this.s._chunksCollection.drop();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}