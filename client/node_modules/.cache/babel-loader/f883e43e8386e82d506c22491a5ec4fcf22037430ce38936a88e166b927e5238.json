{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = executeOperation;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nasync function executeOperation(client, operation, timeoutContext) {\n  var _operation$readPrefer, _session, _session2;\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  const topology = client.topology == null ? await (0, utils_1.abortable)(autoConnect(client), operation.options) : client.topology;\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner;\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({\n      owner,\n      explicit: false\n    });\n  } else if (session.hasEnded) {\n    throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  const readPreference = (_operation$readPrefer = operation.readPreference) !== null && _operation$readPrefer !== void 0 ? _operation$readPrefer : read_preference_1.ReadPreference.primary;\n  const inTransaction = !!((_session = session) !== null && _session !== void 0 && _session.inTransaction());\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === 'runCommand')) {\n    throw new error_1.MongoTransactionError(\"Read preference in a transaction must be primary, not: \".concat(readPreference.mode));\n  }\n  if ((_session2 = session) !== null && _session2 !== void 0 && _session2.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  timeoutContext !== null && timeoutContext !== void 0 ? timeoutContext : timeoutContext = timeout_1.TimeoutContext.create({\n    session,\n    serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,\n    waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,\n    timeoutMS: operation.options.timeoutMS\n  });\n  try {\n    return await tryOperation(operation, {\n      topology,\n      timeoutContext,\n      session,\n      readPreference\n    });\n  } finally {\n    var _session3;\n    if (((_session3 = session) === null || _session3 === void 0 ? void 0 : _session3.owner) != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client) {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options.__skipPingOnConnect = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options.__skipPingOnConnect;\n    }\n  }\n  return client.topology;\n}\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation(operation, _ref) {\n  var _session$inTransactio;\n  let {\n    topology,\n    timeoutContext,\n    session,\n    readPreference\n  } = _ref;\n  let selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    var _operation$server;\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)((_operation$server = operation.server) === null || _operation$server === void 0 ? void 0 : _operation$server.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName,\n    timeoutContext,\n    signal: operation.options.signal\n  });\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const inTransaction = (_session$inTransactio = session === null || session === void 0 ? void 0 : session.inTransaction()) !== null && _session$inTransactio !== void 0 ? _session$inTransactio : false;\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n  const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n  const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) && session != null && (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite);\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n  const maxTries = willRetry ? timeoutContext.csotEnabled() ? Infinity : 2 : 1;\n  let previousOperationError;\n  let previousServer;\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new error_1.MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n      if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {\n        throw previousOperationError;\n      }\n      if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError)) throw previousOperationError;\n      if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError)) throw previousOperationError;\n      if (previousOperationError instanceof error_1.MongoNetworkError && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) && session != null && session.isPinned && !session.inTransaction()) {\n        session.unpin({\n          force: true,\n          forceClear: true\n        });\n      }\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer,\n        signal: operation.options.signal\n      });\n      if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {\n        throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n      }\n    }\n    try {\n      // If tries > 0 and we are command batching we need to reset the batch.\n      if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {\n        operation.resetBatch();\n      }\n      return await operation.execute(server, session, timeoutContext);\n    } catch (operationError) {\n      if (!(operationError instanceof error_1.MongoError)) throw operationError;\n      if (previousOperationError != null && operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n      // Reset timeouts\n      timeoutContext.clear();\n    }\n  }\n  throw previousOperationError !== null && previousOperationError !== void 0 ? previousOperationError : new error_1.MongoRuntimeError('Tried to propagate retryability error, but no error was found.');\n}","map":{"version":3,"names":["exports","executeOperation","error_1","require","read_preference_1","server_selection_1","timeout_1","utils_1","operation_1","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","client","operation","timeoutContext","_operation$readPrefer","_session","_session2","AbstractOperation","MongoRuntimeError","topology","abortable","autoConnect","options","session","owner","Symbol","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","capabilities","supportsSnapshotReads","MongoCompatibilityError","MongoInvalidArgumentError","readPreference","ReadPreference","primary","inTransaction","hasReadAspect","hasAspect","Aspect","READ_OPERATION","equals","commandName","MongoTransactionError","concat","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","TimeoutContext","create","serverSelectionTimeoutMS","s","waitQueueTimeoutMS","timeoutMS","tryOperation","_session3","endSession","hasBeenClosed","MongoNotConnectedError","__skipPingOnConnect","connect","_ref","_session$inTransactio","selector","MUST_SELECT_SAME_SERVER","_operation$server","sameServerSelector","server","description","trySecondaryWrite","secondaryWritableServerSelector","commonWireVersion","selectServer","operationName","signal","hasWriteAspect","WRITE_OPERATION","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","supportsRetryableWrites","canRetryWrite","willRetry","RETRYABLE","incrementTransactionNumber","maxTries","csotEnabled","Infinity","previousOperationError","previousServer","tries","code","MongoServerError","message","errmsg","originalError","COMMAND_BATCHING","isRetryableWriteError","isRetryableReadError","MongoNetworkError","CURSOR_CREATING","force","forceClear","MongoUnexpectedServerResponseError","resetBatch","execute","operationError","MongoError","hasErrorLabel","MongoErrorLabel","NoWritesPerformed","clear"],"sources":["/Users/glebch/workprojects/baumna/client/node_modules/mongodb/src/operations/execute_operation.ts"],"sourcesContent":["import {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { ServerDescription } from '../sdam/server_description';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  type ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { TimeoutContext } from '../timeout';\nimport { abortable, supportsRetryableWrites } from '../utils';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> =\n  TOperation extends AbstractOperation<infer K> ? K : never;\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nexport async function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, timeoutContext?: TimeoutContext | null): Promise<TResult> {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  const topology =\n    client.topology == null\n      ? await abortable(autoConnect(client), operation.options)\n      : client.topology;\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner: symbol | undefined;\n\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({ owner, explicit: false });\n  } else if (session.hasEnded) {\n    throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n\n  if (\n    inTransaction &&\n    !readPreference.equals(ReadPreference.primary) &&\n    (hasReadAspect || operation.commandName === 'runCommand')\n  ) {\n    throw new MongoTransactionError(\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  timeoutContext ??= TimeoutContext.create({\n    session,\n    serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,\n    waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,\n    timeoutMS: operation.options.timeoutMS\n  });\n\n  try {\n    return await tryOperation(operation, {\n      topology,\n      timeoutContext,\n      session,\n      readPreference\n    });\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client: MongoClient): Promise<Topology> {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options.__skipPingOnConnect = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new MongoRuntimeError(\n          'client.connect did not create a topology but also did not throw'\n        );\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options.__skipPingOnConnect;\n    }\n  }\n  return client.topology;\n}\n\n/** @internal */\ntype RetryOptions = {\n  session: ClientSession | undefined;\n  readPreference: ReadPreference;\n  topology: Topology;\n  timeoutContext: TimeoutContext;\n};\n\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(\n  operation: T,\n  { topology, timeoutContext, session, readPreference }: RetryOptions\n): Promise<TResult> {\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName,\n    timeoutContext,\n    signal: operation.options.signal\n  });\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const inTransaction = session?.inTransaction() ?? false;\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n  const willRetryWrite =\n    topology.s.options.retryWrites &&\n    !inTransaction &&\n    supportsRetryableWrites(server) &&\n    operation.canRetryWrite;\n\n  const willRetry =\n    operation.hasAspect(Aspect.RETRYABLE) &&\n    session != null &&\n    ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite));\n\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  const maxTries = willRetry ? (timeoutContext.csotEnabled() ? Infinity : 2) : 1;\n  let previousOperationError: MongoError | undefined;\n  let previousServer: ServerDescription | undefined;\n\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n\n      if (operation.hasAspect(Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {\n        throw previousOperationError;\n      }\n\n      if (hasWriteAspect && !isRetryableWriteError(previousOperationError))\n        throw previousOperationError;\n\n      if (hasReadAspect && !isRetryableReadError(previousOperationError))\n        throw previousOperationError;\n\n      if (\n        previousOperationError instanceof MongoNetworkError &&\n        operation.hasAspect(Aspect.CURSOR_CREATING) &&\n        session != null &&\n        session.isPinned &&\n        !session.inTransaction()\n      ) {\n        session.unpin({ force: true, forceClear: true });\n      }\n\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer,\n        signal: operation.options.signal\n      });\n\n      if (hasWriteAspect && !supportsRetryableWrites(server)) {\n        throw new MongoUnexpectedServerResponseError(\n          'Selected server does not support retryable writes'\n        );\n      }\n    }\n\n    try {\n      // If tries > 0 and we are command batching we need to reset the batch.\n      if (tries > 0 && operation.hasAspect(Aspect.COMMAND_BATCHING)) {\n        operation.resetBatch();\n      }\n      return await operation.execute(server, session, timeoutContext);\n    } catch (operationError) {\n      if (!(operationError instanceof MongoError)) throw operationError;\n      if (\n        previousOperationError != null &&\n        operationError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\n      ) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n\n      // Reset timeouts\n      timeoutContext.clear();\n    }\n  }\n\n  throw (\n    previousOperationError ??\n    new MongoRuntimeError('Tried to propagate retryability error, but no error was found.')\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}