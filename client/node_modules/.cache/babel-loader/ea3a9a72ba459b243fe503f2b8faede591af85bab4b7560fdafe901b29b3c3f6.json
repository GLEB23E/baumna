{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;\nexports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;\nexports.resolveCname = resolveCname;\nconst dns = require(\"dns\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\n/** @public */\nexports.GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n});\nasync function externalCommand(connection, command) {\n  const response = await connection.command((0, utils_1.ns)('$external.$cmd'), command);\n  return response;\n}\nlet krb;\nclass GSSAPI extends auth_provider_1.AuthProvider {\n  async auth(authContext) {\n    const {\n      connection,\n      credentials\n    } = authContext;\n    if (credentials == null) {\n      throw new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication');\n    }\n    const {\n      username\n    } = credentials;\n    const client = await makeKerberosClient(authContext);\n    const payload = await client.step('');\n    const saslStartResponse = await externalCommand(connection, saslStart(payload));\n    const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);\n    const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));\n    const finalizePayload = await finalize(client, username, saslContinueResponse.payload);\n    await externalCommand(connection, {\n      saslContinue: 1,\n      conversationId: saslContinueResponse.conversationId,\n      payload: finalizePayload\n    });\n  }\n}\nexports.GSSAPI = GSSAPI;\nasync function makeKerberosClient(authContext) {\n  var _mechanismProperties$, _mechanismProperties$2;\n  const {\n    hostAddress\n  } = authContext.options;\n  const {\n    credentials\n  } = authContext;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    throw new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.');\n  }\n  loadKrb();\n  if ('kModuleError' in krb) {\n    throw krb['kModuleError'];\n  }\n  const {\n    initializeClient\n  } = krb;\n  const {\n    username,\n    password\n  } = credentials;\n  const mechanismProperties = credentials.mechanismProperties;\n  const serviceName = (_mechanismProperties$ = mechanismProperties.SERVICE_NAME) !== null && _mechanismProperties$ !== void 0 ? _mechanismProperties$ : 'mongodb';\n  const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);\n  const initOptions = {};\n  if (password != null) {\n    // TODO(NODE-5139): These do not match the typescript options in initializeClient\n    Object.assign(initOptions, {\n      user: username,\n      password: password\n    });\n  }\n  const spnHost = (_mechanismProperties$2 = mechanismProperties.SERVICE_HOST) !== null && _mechanismProperties$2 !== void 0 ? _mechanismProperties$2 : host;\n  let spn = \"\".concat(serviceName).concat(process.platform === 'win32' ? '/' : '@').concat(spnHost);\n  if ('SERVICE_REALM' in mechanismProperties) {\n    spn = \"\".concat(spn, \"@\").concat(mechanismProperties.SERVICE_REALM);\n  }\n  return await initializeClient(spn, initOptions);\n}\nfunction saslStart(payload) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  };\n}\nfunction saslContinue(payload, conversationId) {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  };\n}\nasync function negotiate(client, retries, payload) {\n  try {\n    const response = await client.step(payload);\n    return response || '';\n  } catch (error) {\n    if (retries === 0) {\n      // Retries exhausted, raise error\n      throw error;\n    }\n    // Adjust number of retries and call step again\n    return await negotiate(client, retries - 1, payload);\n  }\n}\nasync function finalize(client, user, payload) {\n  // GSS Client Unwrap\n  const response = await client.unwrap(payload);\n  return await client.wrap(response || '', {\n    user\n  });\n}\nasync function performGSSAPICanonicalizeHostName(host, mechanismProperties) {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {\n    return host;\n  }\n  // If forward and reverse or true\n  if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {\n    // Perform the lookup of the ip address.\n    const {\n      address\n    } = await dns.promises.lookup(host);\n    try {\n      // Perform a reverse ptr lookup on the ip address.\n      const results = await dns.promises.resolvePtr(address);\n      // If the ptr did not error but had no results, return the host.\n      return results.length > 0 ? results[0] : host;\n    } catch (_unused) {\n      // This can error as ptr records may not exist for all ips. In this case\n      // fallback to a cname lookup as dns.lookup() does not return the\n      // cname.\n      return await resolveCname(host);\n    }\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    return await resolveCname(host);\n  }\n}\nasync function resolveCname(host) {\n  // Attempt to resolve the host name\n  try {\n    const results = await dns.promises.resolveCname(host);\n    // Get the first resolved host id\n    return results.length > 0 ? results[0] : host;\n  } catch (_unused2) {\n    return host;\n  }\n}\n/**\n * Load the Kerberos library.\n */\nfunction loadKrb() {\n  if (!krb) {\n    krb = (0, deps_1.getKerberos)();\n  }\n}","map":{"version":3,"names":["exports","performGSSAPICanonicalizeHostName","resolveCname","dns","require","deps_1","error_1","utils_1","auth_provider_1","GSSAPICanonicalizationValue","Object","freeze","on","off","none","forward","forwardAndReverse","externalCommand","connection","command","response","ns","krb","GSSAPI","AuthProvider","auth","authContext","credentials","MongoMissingCredentialsError","username","client","makeKerberosClient","payload","step","saslStartResponse","saslStart","negotiatedPayload","negotiate","saslContinueResponse","saslContinue","conversationId","finalizePayload","finalize","_mechanismProperties$","_mechanismProperties$2","hostAddress","options","host","MongoInvalidArgumentError","loadKrb","initializeClient","password","mechanismProperties","serviceName","SERVICE_NAME","initOptions","assign","user","spnHost","SERVICE_HOST","spn","concat","process","platform","SERVICE_REALM","mechanism","autoAuthorize","retries","error","unwrap","wrap","mode","CANONICALIZE_HOST_NAME","address","promises","lookup","results","resolvePtr","length","_unused","_unused2","getKerberos"],"sources":["/Users/glebch/workprojects/baumna/client/node_modules/mongodb/src/cmap/auth/gssapi.ts"],"sourcesContent":["import * as dns from 'dns';\n\nimport { getKerberos, type Kerberos, type KerberosClient } from '../../deps';\nimport { MongoInvalidArgumentError, MongoMissingCredentialsError } from '../../error';\nimport { ns } from '../../utils';\nimport type { Connection } from '../connection';\nimport { type AuthContext, AuthProvider } from './auth_provider';\n\n/** @public */\nexport const GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n} as const);\n\n/** @public */\nexport type GSSAPICanonicalizationValue =\n  (typeof GSSAPICanonicalizationValue)[keyof typeof GSSAPICanonicalizationValue];\n\ntype MechanismProperties = {\n  CANONICALIZE_HOST_NAME?: GSSAPICanonicalizationValue;\n  SERVICE_HOST?: string;\n  SERVICE_NAME?: string;\n  SERVICE_REALM?: string;\n};\n\nasync function externalCommand(\n  connection: Connection,\n  command: ReturnType<typeof saslStart> | ReturnType<typeof saslContinue>\n): Promise<{ payload: string; conversationId: number }> {\n  const response = await connection.command(ns('$external.$cmd'), command);\n  return response as { payload: string; conversationId: number };\n}\n\nlet krb: Kerberos;\n\nexport class GSSAPI extends AuthProvider {\n  override async auth(authContext: AuthContext): Promise<void> {\n    const { connection, credentials } = authContext;\n    if (credentials == null) {\n      throw new MongoMissingCredentialsError('Credentials required for GSSAPI authentication');\n    }\n\n    const { username } = credentials;\n\n    const client = await makeKerberosClient(authContext);\n\n    const payload = await client.step('');\n\n    const saslStartResponse = await externalCommand(connection, saslStart(payload));\n\n    const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);\n\n    const saslContinueResponse = await externalCommand(\n      connection,\n      saslContinue(negotiatedPayload, saslStartResponse.conversationId)\n    );\n\n    const finalizePayload = await finalize(client, username, saslContinueResponse.payload);\n\n    await externalCommand(connection, {\n      saslContinue: 1,\n      conversationId: saslContinueResponse.conversationId,\n      payload: finalizePayload\n    });\n  }\n}\n\nasync function makeKerberosClient(authContext: AuthContext): Promise<KerberosClient> {\n  const { hostAddress } = authContext.options;\n  const { credentials } = authContext;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    throw new MongoInvalidArgumentError(\n      'Connection must have host and port and credentials defined.'\n    );\n  }\n\n  loadKrb();\n  if ('kModuleError' in krb) {\n    throw krb['kModuleError'];\n  }\n  const { initializeClient } = krb;\n\n  const { username, password } = credentials;\n  const mechanismProperties = credentials.mechanismProperties as MechanismProperties;\n\n  const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n\n  const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);\n\n  const initOptions = {};\n  if (password != null) {\n    // TODO(NODE-5139): These do not match the typescript options in initializeClient\n    Object.assign(initOptions, { user: username, password: password });\n  }\n\n  const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n  let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n  if ('SERVICE_REALM' in mechanismProperties) {\n    spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n  }\n\n  return await initializeClient(spn, initOptions);\n}\n\nfunction saslStart(payload: string) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  } as const;\n}\n\nfunction saslContinue(payload: string, conversationId: number) {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  } as const;\n}\n\nasync function negotiate(\n  client: KerberosClient,\n  retries: number,\n  payload: string\n): Promise<string> {\n  try {\n    const response = await client.step(payload);\n    return response || '';\n  } catch (error) {\n    if (retries === 0) {\n      // Retries exhausted, raise error\n      throw error;\n    }\n    // Adjust number of retries and call step again\n    return await negotiate(client, retries - 1, payload);\n  }\n}\n\nasync function finalize(client: KerberosClient, user: string, payload: string): Promise<string> {\n  // GSS Client Unwrap\n  const response = await client.unwrap(payload);\n  return await client.wrap(response || '', { user });\n}\n\nexport async function performGSSAPICanonicalizeHostName(\n  host: string,\n  mechanismProperties: MechanismProperties\n): Promise<string> {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === GSSAPICanonicalizationValue.none) {\n    return host;\n  }\n\n  // If forward and reverse or true\n  if (\n    mode === GSSAPICanonicalizationValue.on ||\n    mode === GSSAPICanonicalizationValue.forwardAndReverse\n  ) {\n    // Perform the lookup of the ip address.\n    const { address } = await dns.promises.lookup(host);\n\n    try {\n      // Perform a reverse ptr lookup on the ip address.\n      const results = await dns.promises.resolvePtr(address);\n      // If the ptr did not error but had no results, return the host.\n      return results.length > 0 ? results[0] : host;\n    } catch {\n      // This can error as ptr records may not exist for all ips. In this case\n      // fallback to a cname lookup as dns.lookup() does not return the\n      // cname.\n      return await resolveCname(host);\n    }\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    return await resolveCname(host);\n  }\n}\n\nexport async function resolveCname(host: string): Promise<string> {\n  // Attempt to resolve the host name\n  try {\n    const results = await dns.promises.resolveCname(host);\n    // Get the first resolved host id\n    return results.length > 0 ? results[0] : host;\n  } catch {\n    return host;\n  }\n}\n\n/**\n * Load the Kerberos library.\n */\nfunction loadKrb() {\n  if (!krb) {\n    krb = getKerberos();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}