{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/glebch/workprojects/baumna/client/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncIterator = require(\"/Users/glebch/workprojects/baumna/client/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nvar _awaitAsyncGenerator = require(\"/Users/glebch/workprojects/baumna/client/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\nvar _wrapAsyncGenerator = require(\"/Users/glebch/workprojects/baumna/client/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CursorTimeoutContext = exports.AbstractCursor = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst resource_management_1 = require(\"../resource_management\");\nconst sessions_1 = require(\"../sessions\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\nfunction removeActiveCursor() {\n  this.client.s.activeCursors.delete(this);\n}\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\nexports.CursorTimeoutMode = Object.freeze({\n  ITERATION: 'iteration',\n  LIFETIME: 'cursorLifetime'\n});\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace) {\n    var _options$timeoutConte;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    /** @internal */\n    this.documents = null;\n    /** @internal */\n    this.hasEmittedClose = false;\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = _objectSpread(_objectSpread({\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary\n    }, (0, bson_1.pluckBSONSerializeOptions)(options)), {}, {\n      timeoutMS: options !== null && options !== void 0 && (_options$timeoutConte = options.timeoutContext) !== null && _options$timeoutConte !== void 0 && _options$timeoutConte.csotEnabled() ? options.timeoutContext.timeoutMS : options.timeoutMS,\n      tailable: options.tailable,\n      awaitData: options.awaitData\n    });\n    if (this.cursorOptions.timeoutMS != null) {\n      if (options.timeoutMode == null) {\n        if (options.tailable) {\n          if (options.awaitData) {\n            if (options.maxAwaitTimeMS != null && options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS) throw new error_1.MongoInvalidArgumentError('Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor');\n          }\n          this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.ITERATION;\n        } else {\n          this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.LIFETIME;\n        }\n      } else {\n        if (options.tailable && options.timeoutMode === exports.CursorTimeoutMode.LIFETIME) {\n          throw new error_1.MongoInvalidArgumentError(\"Cannot set tailable cursor's timeoutMode to LIFETIME\");\n        }\n        this.cursorOptions.timeoutMode = options.timeoutMode;\n      }\n    } else {\n      if (options.timeoutMode != null) throw new error_1.MongoInvalidArgumentError('Cannot set timeoutMode without setting timeoutMS');\n    }\n    // Set for initial command\n    this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null && (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && !this.cursorOptions.tailable || this.cursorOptions.tailable && !this.cursorOptions.awaitData);\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      this.cursorSession = options.session;\n    } else {\n      this.cursorSession = this.cursorClient.startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n    this.deserializationOptions = _objectSpread(_objectSpread({}, this.cursorOptions), {}, {\n      validation: {\n        utf8: (options === null || options === void 0 ? void 0 : options.enableUtf8Validation) === false ? false : true\n      }\n    });\n    this.timeoutContext = options.timeoutContext;\n    this.signal = options.signal;\n    this.abortListener = (0, utils_1.addAbortListener)(this.signal, () => void this.close().then(undefined, utils_1.squashError));\n    this.trackCursor();\n  }\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id() {\n    var _this$cursorId;\n    return (_this$cursorId = this.cursorId) !== null && _this$cursorId !== void 0 ? _this$cursorId : undefined;\n  }\n  /** @internal */\n  get isDead() {\n    var _this$cursorId$isZero, _this$cursorId2;\n    return ((_this$cursorId$isZero = (_this$cursorId2 = this.cursorId) === null || _this$cursorId2 === void 0 ? void 0 : _this$cursorId2.isZero()) !== null && _this$cursorId$isZero !== void 0 ? _this$cursorId$isZero : false) || this.isClosed || this.isKilled;\n  }\n  /** @internal */\n  get client() {\n    return this.cursorClient;\n  }\n  /** @internal */\n  get server() {\n    return this.selectedServer;\n  }\n  get namespace() {\n    return this.cursorNamespace;\n  }\n  get readPreference() {\n    return this.cursorOptions.readPreference;\n  }\n  get readConcern() {\n    return this.cursorOptions.readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this.cursorSession;\n  }\n  set session(clientSession) {\n    this.cursorSession = clientSession;\n  }\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed() {\n    var _this$documents$lengt, _this$documents;\n    return this.isClosed && ((_this$documents$lengt = (_this$documents = this.documents) === null || _this$documents === void 0 ? void 0 : _this$documents.length) !== null && _this$documents$lengt !== void 0 ? _this$documents$lengt : 0) === 0;\n  }\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed() {\n    return this.isKilled;\n  }\n  get loadBalanced() {\n    var _this$cursorClient$to;\n    return !!((_this$cursorClient$to = this.cursorClient.topology) !== null && _this$cursorClient$to !== void 0 && _this$cursorClient$to.loadBalanced);\n  }\n  /** @internal */\n  async asyncDispose() {\n    await this.close();\n  }\n  /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */\n  trackCursor() {\n    this.cursorClient.s.activeCursors.add(this);\n    if (!this.listeners('close').includes(removeActiveCursor)) {\n      this.once('close', removeActiveCursor);\n    }\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    var _this$documents$lengt2, _this$documents2;\n    return (_this$documents$lengt2 = (_this$documents2 = this.documents) === null || _this$documents2 === void 0 ? void 0 : _this$documents2.length) !== null && _this$documents$lengt2 !== void 0 ? _this$documents$lengt2 : 0;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    var _ref, _this$documents3, _this$documents$lengt3, _this$documents4;\n    const bufferedDocs = [];\n    const documentsToRead = Math.min((_ref = number !== null && number !== void 0 ? number : (_this$documents3 = this.documents) === null || _this$documents3 === void 0 ? void 0 : _this$documents3.length) !== null && _ref !== void 0 ? _ref : 0, (_this$documents$lengt3 = (_this$documents4 = this.documents) === null || _this$documents4 === void 0 ? void 0 : _this$documents4.length) !== null && _this$documents$lengt3 !== void 0 ? _this$documents$lengt3 : 0);\n    for (let count = 0; count < documentsToRead; count++) {\n      var _this$documents5;\n      const document = (_this$documents5 = this.documents) === null || _this$documents5 === void 0 ? void 0 : _this$documents5.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n    return bufferedDocs;\n  }\n  [Symbol.asyncIterator]() {\n    var _this = this;\n    return _wrapAsyncGenerator(function* () {\n      var _this$signal;\n      (_this$signal = _this.signal) === null || _this$signal === void 0 || _this$signal.throwIfAborted();\n      if (_this.closed) {\n        return;\n      }\n      try {\n        while (true) {\n          var _this$documents$lengt4, _this$documents6, _this$signal2;\n          if (_this.isKilled) {\n            return;\n          }\n          if (_this.closed) {\n            return;\n          }\n          if (_this.cursorId != null && _this.isDead && ((_this$documents$lengt4 = (_this$documents6 = _this.documents) === null || _this$documents6 === void 0 ? void 0 : _this$documents6.length) !== null && _this$documents$lengt4 !== void 0 ? _this$documents$lengt4 : 0) === 0) {\n            return;\n          }\n          const document = yield _awaitAsyncGenerator(_this.next());\n          // eslint-disable-next-line no-restricted-syntax\n          if (document === null) {\n            return;\n          }\n          yield document;\n          (_this$signal2 = _this.signal) === null || _this$signal2 === void 0 || _this$signal2.throwIfAborted();\n        }\n      } finally {\n        // Only close the cursor if it has not already been closed. This finally clause handles\n        // the case when a user would break out of a for await of loop early.\n        if (!_this.isClosed) {\n          try {\n            yield _awaitAsyncGenerator(_this.close());\n          } catch (error) {\n            (0, utils_1.squashError)(error);\n          }\n        }\n      }\n    })();\n  }\n  stream(options) {\n    const readable = new ReadableCursorStream(this);\n    const abortListener = (0, utils_1.addAbortListener)(this.signal, function () {\n      readable.destroy(this.reason);\n    });\n    readable.once('end', () => {\n      abortListener === null || abortListener === void 0 || abortListener[utils_1.kDispose]();\n    });\n    if (options !== null && options !== void 0 && options.transform) {\n      const transform = options.transform;\n      const transformedStream = readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n      }));\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n      return transformedStream;\n    }\n    return readable;\n  }\n  async hasNext() {\n    var _this$signal3;\n    (_this$signal3 = this.signal) === null || _this$signal3 === void 0 || _this$signal3.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      return false;\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      var _this$timeoutContext;\n      (_this$timeoutContext = this.timeoutContext) === null || _this$timeoutContext === void 0 || _this$timeoutContext.refresh();\n    }\n    try {\n      do {\n        var _this$documents$lengt5, _this$documents7, _this$documents$lengt6, _this$documents8;\n        if (((_this$documents$lengt5 = (_this$documents7 = this.documents) === null || _this$documents7 === void 0 ? void 0 : _this$documents7.length) !== null && _this$documents$lengt5 !== void 0 ? _this$documents$lengt5 : 0) !== 0) {\n          return true;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || ((_this$documents$lengt6 = (_this$documents8 = this.documents) === null || _this$documents8 === void 0 ? void 0 : _this$documents8.length) !== null && _this$documents$lengt6 !== void 0 ? _this$documents$lengt6 : 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        var _this$timeoutContext2;\n        (_this$timeoutContext2 = this.timeoutContext) === null || _this$timeoutContext2 === void 0 || _this$timeoutContext2.clear();\n      }\n    }\n    return false;\n  }\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next() {\n    var _this$signal4;\n    (_this$signal4 = this.signal) === null || _this$signal4 === void 0 || _this$signal4.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      var _this$timeoutContext3;\n      (_this$timeoutContext3 = this.timeoutContext) === null || _this$timeoutContext3 === void 0 || _this$timeoutContext3.refresh();\n    }\n    try {\n      do {\n        var _this$documents9, _this$documents$lengt7, _this$documents10;\n        const doc = (_this$documents9 = this.documents) === null || _this$documents9 === void 0 ? void 0 : _this$documents9.shift(this.deserializationOptions);\n        if (doc != null) {\n          if (this.transform != null) return await this.transformDocument(doc);\n          return doc;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || ((_this$documents$lengt7 = (_this$documents10 = this.documents) === null || _this$documents10 === void 0 ? void 0 : _this$documents10.length) !== null && _this$documents$lengt7 !== void 0 ? _this$documents$lengt7 : 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        var _this$timeoutContext4;\n        (_this$timeoutContext4 = this.timeoutContext) === null || _this$timeoutContext4 === void 0 || _this$timeoutContext4.clear();\n      }\n    }\n    return null;\n  }\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext() {\n    var _this$signal5;\n    (_this$signal5 = this.signal) === null || _this$signal5 === void 0 || _this$signal5.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      var _this$timeoutContext5;\n      (_this$timeoutContext5 = this.timeoutContext) === null || _this$timeoutContext5 === void 0 || _this$timeoutContext5.refresh();\n    }\n    try {\n      var _this$documents11, _this$documents12;\n      let doc = (_this$documents11 = this.documents) === null || _this$documents11 === void 0 ? void 0 : _this$documents11.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n      await this.fetchBatch();\n      doc = (_this$documents12 = this.documents) === null || _this$documents12 === void 0 ? void 0 : _this$documents12.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        var _this$timeoutContext6;\n        (_this$timeoutContext6 = this.timeoutContext) === null || _this$timeoutContext6 === void 0 || _this$timeoutContext6.clear();\n      }\n    }\n    return null;\n  }\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator) {\n    var _this$signal6;\n    (_this$signal6 = this.signal) === null || _this$signal6 === void 0 || _this$signal6.throwIfAborted();\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(this), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const document = _step.value;\n        {\n          const result = iterator(document);\n          if (result === false) {\n            break;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(options) {\n    await this.cleanup(options === null || options === void 0 ? void 0 : options.timeoutMS);\n  }\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray() {\n    var _this$signal7;\n    (_this$signal7 = this.signal) === null || _this$signal7 === void 0 || _this$signal7.throwIfAborted();\n    const array = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    var _iteratorAbruptCompletion2 = false;\n    var _didIteratorError2 = false;\n    var _iteratorError2;\n    try {\n      for (var _iterator2 = _asyncIterator(this), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n        const document = _step2.value;\n        {\n          array.push(document);\n          const docs = this.readBufferedDocuments();\n          if (this.transform != null) {\n            for (const doc of docs) {\n              array.push(await this.transformDocument(doc));\n            }\n          } else {\n            array.push(...docs);\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n          await _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag, value) {\n    this.throwIfInitialized();\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(\"Flag \".concat(flag, \" is not one of \").concat(exports.CURSOR_FLAGS));\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(\"Flag \".concat(flag, \" must be a boolean value\"));\n    }\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map(transform) {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference) {\n    this.throwIfInitialized();\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(\"Invalid read preference: \".concat(readPreference));\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern) {\n    this.throwIfInitialized();\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value) {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value) {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind() {\n    var _this$documents13, _this$timeoutContext7;\n    if (this.timeoutContext && this.timeoutContext.owner !== this) {\n      throw new error_1.MongoAPIError(\"Cannot rewind cursor that does not own its timeout context.\");\n    }\n    if (!this.initialized) {\n      return;\n    }\n    this.cursorId = null;\n    (_this$documents13 = this.documents) === null || _this$documents13 === void 0 || _this$documents13.clear();\n    (_this$timeoutContext7 = this.timeoutContext) === null || _this$timeoutContext7 === void 0 || _this$timeoutContext7.clear();\n    this.timeoutContext = undefined;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n    this.hasEmittedClose = false;\n    this.trackCursor();\n    // We only want to end this session if we created it, and it hasn't ended yet\n    if (this.cursorSession.explicit === false) {\n      if (!this.cursorSession.hasEnded) {\n        this.cursorSession.endSession().then(undefined, utils_1.squashError);\n      }\n      this.cursorSession = this.cursorClient.startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n  }\n  /** @internal */\n  async getMore(batchSize) {\n    if (this.cursorId == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null cursor id. A cursor creating command should have set this');\n    }\n    if (this.selectedServer == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null selectedServer. A cursor creating command should have set this');\n    }\n    const getMoreOptions = _objectSpread(_objectSpread({}, this.cursorOptions), {}, {\n      session: this.cursorSession,\n      batchSize\n    });\n    const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, getMoreOptions);\n    return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation, this.timeoutContext);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  async cursorInit() {\n    if (this.cursorOptions.timeoutMS != null) {\n      var _this$timeoutContext8;\n      (_this$timeoutContext8 = this.timeoutContext) !== null && _this$timeoutContext8 !== void 0 ? _this$timeoutContext8 : this.timeoutContext = new CursorTimeoutContext(timeout_1.TimeoutContext.create({\n        serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n        timeoutMS: this.cursorOptions.timeoutMS\n      }), this);\n    }\n    try {\n      var _response$ns;\n      const state = await this._initialize(this.cursorSession);\n      // Set omitMaxTimeMS to the value needed for subsequent getMore calls\n      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = (_response$ns = response.ns) !== null && _response$ns !== void 0 ? _response$ns : this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(undefined, error);\n      throw error;\n    }\n    if (this.isDead) {\n      await this.cleanup();\n    }\n    return;\n  }\n  /** @internal Attempt to obtain more documents */\n  async fetchBatch() {\n    if (this.isClosed) {\n      return;\n    }\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n    if (this.cursorId == null) {\n      var _this$documents$lengt8, _this$documents14;\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if (((_this$documents$lengt8 = (_this$documents14 = this.documents) === null || _this$documents14 === void 0 ? void 0 : _this$documents14.length) !== null && _this$documents$lengt8 !== void 0 ? _this$documents$lengt8 : 0) !== 0 || this.isDead) return;\n      // Otherwise, run a getMore\n    }\n    // otherwise need to call getMore\n    const batchSize = this.cursorOptions.batchSize || 1000;\n    try {\n      const response = await this.getMore(batchSize);\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(undefined, error);\n      } catch (cleanupError) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        (0, utils_1.squashError)(cleanupError);\n      }\n      throw error;\n    }\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n  /** @internal */\n  async cleanup(timeoutMS, error) {\n    var _this$abortListener;\n    (_this$abortListener = this.abortListener) === null || _this$abortListener === void 0 || _this$abortListener[utils_1.kDispose]();\n    this.isClosed = true;\n    const timeoutContextForKillCursors = () => {\n      if (timeoutMS != null) {\n        var _this$timeoutContext9;\n        (_this$timeoutContext9 = this.timeoutContext) === null || _this$timeoutContext9 === void 0 || _this$timeoutContext9.clear();\n        return new CursorTimeoutContext(timeout_1.TimeoutContext.create({\n          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n          timeoutMS\n        }), this);\n      } else {\n        var _this$timeoutContext10;\n        return (_this$timeoutContext10 = this.timeoutContext) === null || _this$timeoutContext10 === void 0 ? void 0 : _this$timeoutContext10.refreshed();\n      }\n    };\n    try {\n      if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !this.cursorSession.hasEnded) {\n        this.isKilled = true;\n        const cursorId = this.cursorId;\n        this.cursorId = bson_1.Long.ZERO;\n        await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n          session: this.cursorSession\n        }), timeoutContextForKillCursors());\n      }\n    } catch (error) {\n      (0, utils_1.squashError)(error);\n    } finally {\n      try {\n        var _this$cursorSession, _this$cursorSession2;\n        if (((_this$cursorSession = this.cursorSession) === null || _this$cursorSession === void 0 ? void 0 : _this$cursorSession.owner) === this) {\n          await this.cursorSession.endSession({\n            error\n          });\n        }\n        if (!((_this$cursorSession2 = this.cursorSession) !== null && _this$cursorSession2 !== void 0 && _this$cursorSession2.inTransaction())) {\n          (0, sessions_1.maybeClearPinnedConnection)(this.cursorSession, {\n            error\n          });\n        }\n      } finally {\n        this.emitClose();\n      }\n    }\n  }\n  /** @internal */\n  emitClose() {\n    try {\n      var _this$documents$lengt9, _this$documents15;\n      if (!this.hasEmittedClose && (((_this$documents$lengt9 = (_this$documents15 = this.documents) === null || _this$documents15 === void 0 ? void 0 : _this$documents15.length) !== null && _this$documents$lengt9 !== void 0 ? _this$documents$lengt9 : 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n  /** @internal */\n  async transformDocument(document) {\n    if (this.transform == null) return document;\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        (0, utils_1.squashError)(closeError);\n      }\n      throw transformError;\n    }\n  }\n  /** @internal */\n  throwIfInitialized() {\n    if (this.initialized) throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n  _destroy(error, callback) {\n    this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n  }\n  _readNext() {\n    if (this._cursor.id === bson_1.Long.ZERO) {\n      this.push(null);\n      return;\n    }\n    this._cursor.next().then(result => {\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n        this._readInProgress = false;\n      }\n    }, err => {\n      // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n      //       desired behavior is that a stream ends cleanly when a user explicitly closes\n      //       a client during iteration. Alternatively, we could do the \"right\" thing and\n      //       propagate the error message by removing this special case.\n      if (err.message.match(/server is closed/)) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n        return this.push(null);\n      }\n      // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n      //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n      //       active getMore in-flight. This used to check if the cursor was killed but once\n      //       that changed to happen in cleanup legitimate errors would not destroy the\n      //       stream. There are change streams test specifically test these cases.\n      if (err.message.match(/operation was interrupted/)) {\n        return this.push(null);\n      }\n      // NOTE: The two above checks on the message of the error will cause a null to be pushed\n      //       to the stream, thus closing the stream before the destroy call happens. This means\n      //       that either of those error messages on a change stream will not get a proper\n      //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n      //       relies on that error event to be emitted to create its new cursor and thus was not\n      //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n      //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n      //       See NODE-4475.\n      return this.destroy(err);\n    });\n  }\n}\n(0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);\n/**\n * @internal\n * The cursor timeout context is a wrapper around a timeout context\n * that keeps track of the \"owner\" of the cursor.  For timeout contexts\n * instantiated inside a cursor, the owner will be the cursor.\n *\n * All timeout behavior is exactly the same as the wrapped timeout context's.\n */\nclass CursorTimeoutContext extends timeout_1.TimeoutContext {\n  constructor(timeoutContext, owner) {\n    super();\n    this.timeoutContext = timeoutContext;\n    this.owner = owner;\n  }\n  get serverSelectionTimeout() {\n    return this.timeoutContext.serverSelectionTimeout;\n  }\n  get connectionCheckoutTimeout() {\n    return this.timeoutContext.connectionCheckoutTimeout;\n  }\n  get clearServerSelectionTimeout() {\n    return this.timeoutContext.clearServerSelectionTimeout;\n  }\n  get timeoutForSocketWrite() {\n    return this.timeoutContext.timeoutForSocketWrite;\n  }\n  get timeoutForSocketRead() {\n    return this.timeoutContext.timeoutForSocketRead;\n  }\n  csotEnabled() {\n    return this.timeoutContext.csotEnabled();\n  }\n  refresh() {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.refresh();\n  }\n  clear() {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.clear();\n  }\n  get maxTimeMS() {\n    return this.timeoutContext.maxTimeMS;\n  }\n  get timeoutMS() {\n    return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;\n  }\n  refreshed() {\n    return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);\n  }\n  addMaxTimeMSToCommand(command, options) {\n    this.timeoutContext.addMaxTimeMSToCommand(command, options);\n  }\n  getSocketTimeoutMS() {\n    return this.timeoutContext.getSocketTimeoutMS();\n  }\n}\nexports.CursorTimeoutContext = CursorTimeoutContext;","map":{"version":3,"names":["stream_1","require","bson_1","error_1","mongo_types_1","execute_operation_1","get_more_1","kill_cursors_1","read_concern_1","read_preference_1","resource_management_1","sessions_1","timeout_1","utils_1","exports","CURSOR_FLAGS","removeActiveCursor","client","s","activeCursors","delete","CursorTimeoutMode","Object","freeze","ITERATION","LIFETIME","AbstractCursor","TypedEventEmitter","constructor","namespace","_options$timeoutConte","options","arguments","length","undefined","documents","hasEmittedClose","isMongoClient","MongoRuntimeError","cursorClient","cursorNamespace","cursorId","initialized","isClosed","isKilled","cursorOptions","_objectSpread","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","timeoutMS","timeoutContext","csotEnabled","tailable","awaitData","timeoutMode","maxAwaitTimeMS","MongoInvalidArgumentError","omitMaxTimeMS","readConcern","ReadConcern","fromOptions","batchSize","comment","maxTimeMS","session","ClientSession","cursorSession","startSession","owner","explicit","deserializationOptions","validation","utf8","enableUtf8Validation","signal","abortListener","addAbortListener","close","then","squashError","trackCursor","id","_this$cursorId","isDead","_this$cursorId$isZero","_this$cursorId2","isZero","server","selectedServer","clientSession","closed","_this$documents$lengt","_this$documents","killed","loadBalanced","_this$cursorClient$to","topology","asyncDispose","add","listeners","includes","once","bufferedCount","_this$documents$lengt2","_this$documents2","readBufferedDocuments","number","_ref","_this$documents3","_this$documents$lengt3","_this$documents4","bufferedDocs","documentsToRead","Math","min","count","_this$documents5","document","shift","push","Symbol","asyncIterator","_this","_wrapAsyncGenerator","_this$signal","throwIfAborted","_this$documents$lengt4","_this$documents6","_this$signal2","_awaitAsyncGenerator","next","error","stream","readable","ReadableCursorStream","destroy","reason","kDispose","transform","transformedStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","err","on","emit","hasNext","_this$signal3","Long","ZERO","_this$timeoutContext","refresh","_this$documents$lengt5","_this$documents7","_this$documents$lengt6","_this$documents8","fetchBatch","_this$timeoutContext2","clear","_this$signal4","MongoCursorExhaustedError","_this$timeoutContext3","_this$documents9","_this$documents$lengt7","_this$documents10","doc","transformDocument","_this$timeoutContext4","tryNext","_this$signal5","_this$timeoutContext5","_this$documents11","_this$documents12","_this$timeoutContext6","forEach","iterator","_this$signal6","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","done","value","result","return","cleanup","toArray","_this$signal7","array","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","docs","addCursorFlag","flag","throwIfInitialized","concat","map","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","MongoTailableCursorError","rewind","_this$documents13","_this$timeoutContext7","MongoAPIError","hasEnded","endSession","getMore","getMoreOptions","getMoreOperation","GetMoreOperation","executeOperation","cursorInit","_this$timeoutContext8","CursorTimeoutContext","TimeoutContext","create","serverSelectionTimeoutMS","_response$ns","state","_initialize","response","ns","_this$documents$lengt8","_this$documents14","cleanupError","_this$abortListener","timeoutContextForKillCursors","_this$timeoutContext9","_this$timeoutContext10","refreshed","KillCursorsOperation","_this$cursorSession","_this$cursorSession2","inTransaction","maybeClearPinnedConnection","emitClose","_this$documents$lengt9","_this$documents15","transformedDocument","TRANSFORM_TO_NULL_ERROR","transformError","closeError","MongoCursorInUseError","CLOSE","Readable","cursor","autoDestroy","_readInProgress","_cursor","_read","size","_readNext","_destroy","destroyed","message","match","configureResourceManagement","prototype","serverSelectionTimeout","connectionCheckoutTimeout","clearServerSelectionTimeout","timeoutForSocketWrite","timeoutForSocketRead","addMaxTimeMSToCommand","command","getSocketTimeoutMS"],"sources":["/Users/glebch/workprojects/baumna/client/node_modules/mongodb/src/cursor/abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\n\nimport { type BSONSerializeOptions, type Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport { type OnDemandDocumentDeserializeOptions } from '../cmap/wire_protocol/on_demand/document';\nimport { type CursorResponse } from '../cmap/wire_protocol/responses';\nimport {\n  MongoAPIError,\n  MongoCursorExhaustedError,\n  MongoCursorInUseError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoTailableCursorError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { type Abortable, TypedEventEmitter } from '../mongo_types';\nimport { executeOperation } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { KillCursorsOperation } from '../operations/kill_cursors';\nimport { ReadConcern, type ReadConcernLike } from '../read_concern';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport { type AsyncDisposable, configureResourceManagement } from '../resource_management';\nimport type { Server } from '../sdam/server';\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\nimport { type CSOTTimeoutContext, type Timeout, TimeoutContext } from '../timeout';\nimport {\n  addAbortListener,\n  type Disposable,\n  kDispose,\n  type MongoDBNamespace,\n  squashError\n} from '../utils';\n\n/**\n * @internal\n * TODO(NODE-2882): A cursor's getMore commands must be run on the same server it was started on\n * and the same session must be used for the lifetime of the cursor. This object serves to get the\n * server and session (along with the response) out of executeOperation back to the AbstractCursor.\n *\n * There may be a better design for communicating these values back to the cursor, currently an operation\n * MUST store the selected server on itself so it can be read after executeOperation has returned.\n */\nexport interface InitialCursorResponse {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: CursorResponse;\n}\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public */\nexport interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(this: void, doc: Document): Document;\n}\n\n/** @public */\nexport type CursorFlag = (typeof CURSOR_FLAGS)[number];\n\nfunction removeActiveCursor(this: AbstractCursor) {\n  this.client.s.activeCursors.delete(this);\n}\n\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\nexport const CursorTimeoutMode = Object.freeze({\n  ITERATION: 'iteration',\n  LIFETIME: 'cursorLifetime'\n} as const);\n\n/**\n * @public\n * @experimental\n */\nexport type CursorTimeoutMode = (typeof CursorTimeoutMode)[keyof typeof CursorTimeoutMode];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  /**\n   * Specifies the number of documents to return in each response from MongoDB\n   */\n  batchSize?: number;\n  /**\n   * When applicable `maxTimeMS` controls the amount of time the initial command\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\n   */\n  maxTimeMS?: number;\n  /**\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\n   */\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /**\n   * By default, MongoDB will automatically close a cursor when the\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\n   * you may use a Tailable Cursor that remains open after the client exhausts\n   * the results in the initial cursor.\n   */\n  tailable?: boolean;\n  /**\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\n   * When new data is inserted into the capped collection, the blocked thread is signaled\n   * to wake up and return the next batch to the client.\n   */\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** Specifies the time an operation will run until it throws a timeout error. See {@link AbstractCursorOptions.timeoutMode} for more details on how this option applies to cursors. */\n  timeoutMS?: number;\n  /**\n   * @public\n   * @experimental\n   * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n   * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n   * `cursor.next()`.\n   * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n   *\n   * Depending on the type of cursor being used, this option has different default values.\n   * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n   * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n   * definition can have an arbitrarily long lifetime.\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n   * for await (const doc of cursor) {\n   *  // process doc\n   *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n   *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n   * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n   * ```\n   */\n  timeoutMode?: CursorTimeoutMode;\n\n  /**\n   * @internal\n   *\n   * A timeout context to govern the total time the cursor can live.  If provided, the cursor\n   * cannot be used in ITERATION mode.\n   */\n  timeoutContext?: CursorTimeoutContext;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n\n  omitMaxTimeMS?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n    TSchema = any,\n    CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n  >\n  extends TypedEventEmitter<CursorEvents>\n  implements AsyncDisposable\n{\n  /** @internal */\n  private cursorId: Long | null;\n  /** @internal */\n  private cursorSession: ClientSession;\n  /** @internal */\n  private selectedServer?: Server;\n  /** @internal */\n  private cursorNamespace: MongoDBNamespace;\n  /** @internal */\n  private documents: CursorResponse | null = null;\n  /** @internal */\n  private cursorClient: MongoClient;\n  /** @internal */\n  private transform?: (doc: TSchema) => any;\n  /**\n   * @internal\n   * This is true whether or not the first command fails. It only indicates whether or not the first\n   * command has been run.\n   */\n  private initialized: boolean;\n  /** @internal */\n  private isClosed: boolean;\n  /** @internal */\n  private isKilled: boolean;\n  /** @internal */\n  protected readonly cursorOptions: InternalAbstractCursorOptions;\n  /** @internal */\n  protected timeoutContext?: CursorTimeoutContext;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  protected deserializationOptions: OnDemandDocumentDeserializeOptions;\n  protected signal: AbortSignal | undefined;\n  private abortListener: Disposable | undefined;\n\n  /** @internal */\n  protected constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions & Abortable = {}\n  ) {\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options),\n      timeoutMS: options?.timeoutContext?.csotEnabled()\n        ? options.timeoutContext.timeoutMS\n        : options.timeoutMS,\n      tailable: options.tailable,\n      awaitData: options.awaitData\n    };\n\n    if (this.cursorOptions.timeoutMS != null) {\n      if (options.timeoutMode == null) {\n        if (options.tailable) {\n          if (options.awaitData) {\n            if (\n              options.maxAwaitTimeMS != null &&\n              options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS\n            )\n              throw new MongoInvalidArgumentError(\n                'Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor'\n              );\n          }\n\n          this.cursorOptions.timeoutMode = CursorTimeoutMode.ITERATION;\n        } else {\n          this.cursorOptions.timeoutMode = CursorTimeoutMode.LIFETIME;\n        }\n      } else {\n        if (options.tailable && options.timeoutMode === CursorTimeoutMode.LIFETIME) {\n          throw new MongoInvalidArgumentError(\n            \"Cannot set tailable cursor's timeoutMode to LIFETIME\"\n          );\n        }\n        this.cursorOptions.timeoutMode = options.timeoutMode;\n      }\n    } else {\n      if (options.timeoutMode != null)\n        throw new MongoInvalidArgumentError('Cannot set timeoutMode without setting timeoutMS');\n    }\n\n    // Set for initial command\n    this.cursorOptions.omitMaxTimeMS =\n      this.cursorOptions.timeoutMS != null &&\n      ((this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&\n        !this.cursorOptions.tailable) ||\n        (this.cursorOptions.tailable && !this.cursorOptions.awaitData));\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    if (options.session instanceof ClientSession) {\n      this.cursorSession = options.session;\n    } else {\n      this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });\n    }\n\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n\n    this.timeoutContext = options.timeoutContext;\n    this.signal = options.signal;\n    this.abortListener = addAbortListener(\n      this.signal,\n      () => void this.close().then(undefined, squashError)\n    );\n    this.trackCursor();\n  }\n\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id(): Long | undefined {\n    return this.cursorId ?? undefined;\n  }\n\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n\n  /** @internal */\n  get client(): MongoClient {\n    return this.cursorClient;\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this.selectedServer;\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this.cursorNamespace;\n  }\n\n  get readPreference(): ReadPreference {\n    return this.cursorOptions.readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this.cursorOptions.readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession {\n    return this.cursorSession;\n  }\n\n  set session(clientSession: ClientSession) {\n    this.cursorSession = clientSession;\n  }\n\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed(): boolean {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed(): boolean {\n    return this.isKilled;\n  }\n\n  get loadBalanced(): boolean {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n\n  /**\n   * @beta\n   * @experimental\n   * An alias for {@link AbstractCursor.close|AbstractCursor.close()}.\n   */\n  declare [Symbol.asyncDispose]: () => Promise<void>;\n  /** @internal */\n  async asyncDispose() {\n    await this.close();\n  }\n\n  /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */\n  private trackCursor() {\n    this.cursorClient.s.activeCursors.add(this);\n    if (!this.listeners('close').includes(removeActiveCursor)) {\n      this.once('close', removeActiveCursor);\n    }\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this.documents?.length ?? 0;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): NonNullable<TSchema>[] {\n    const bufferedDocs: NonNullable<TSchema>[] = [];\n    const documentsToRead = Math.min(\n      number ?? this.documents?.length ?? 0,\n      this.documents?.length ?? 0\n    );\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void> {\n    this.signal?.throwIfAborted();\n\n    if (this.closed) {\n      return;\n    }\n\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n\n        if (this.closed) {\n          return;\n        }\n\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n\n        const document = await this.next();\n\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n\n        yield document;\n\n        this.signal?.throwIfAborted();\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          squashError(error);\n        }\n      }\n    }\n  }\n\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema> {\n    const readable = new ReadableCursorStream(this);\n    const abortListener = addAbortListener(this.signal, function () {\n      readable.destroy(this.reason);\n    });\n    readable.once('end', () => {\n      abortListener?.[kDispose]();\n    });\n\n    if (options?.transform) {\n      const transform = options.transform;\n\n      const transformedStream = readable.pipe(\n        new Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform(chunk, _, callback) {\n            try {\n              const transformed = transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        })\n      );\n\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n\n      return transformedStream;\n    }\n\n    return readable;\n  }\n\n  async hasNext(): Promise<boolean> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      return false;\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        if ((this.documents?.length ?? 0) !== 0) {\n          return true;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return false;\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next(): Promise<TSchema | null> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n\n    try {\n      do {\n        const doc = this.documents?.shift(this.deserializationOptions);\n        if (doc != null) {\n          if (this.transform != null) return await this.transformDocument(doc);\n          return doc;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext(): Promise<TSchema | null> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      let doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n\n      await this.fetchBatch();\n\n      doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator: (doc: TSchema) => boolean | void): Promise<void> {\n    this.signal?.throwIfAborted();\n\n    if (typeof iterator !== 'function') {\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(options?: { timeoutMS?: number }): Promise<void> {\n    await this.cleanup(options?.timeoutMS);\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray(): Promise<TSchema[]> {\n    this.signal?.throwIfAborted();\n\n    const array: TSchema[] = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        array.push(...docs);\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    this.throwIfInitialized();\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n\n    return this as unknown as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    this.throwIfInitialized();\n    if (readPreference instanceof ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    this.throwIfInitialized();\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (this.timeoutContext && this.timeoutContext.owner !== this) {\n      throw new MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);\n    }\n    if (!this.initialized) {\n      return;\n    }\n\n    this.cursorId = null;\n    this.documents?.clear();\n    this.timeoutContext?.clear();\n    this.timeoutContext = undefined;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n    this.hasEmittedClose = false;\n    this.trackCursor();\n\n    // We only want to end this session if we created it, and it hasn't ended yet\n    if (this.cursorSession.explicit === false) {\n      if (!this.cursorSession.hasEnded) {\n        this.cursorSession.endSession().then(undefined, squashError);\n      }\n      this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  protected abstract _initialize(\n    session: ClientSession | undefined\n  ): Promise<InitialCursorResponse>;\n\n  /** @internal */\n  async getMore(batchSize: number): Promise<CursorResponse> {\n    if (this.cursorId == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null cursor id. A cursor creating command should have set this'\n      );\n    }\n    if (this.selectedServer == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null selectedServer. A cursor creating command should have set this'\n      );\n    }\n    const getMoreOptions = {\n      ...this.cursorOptions,\n      session: this.cursorSession,\n      batchSize\n    };\n\n    const getMoreOperation = new GetMoreOperation(\n      this.cursorNamespace,\n      this.cursorId,\n      this.selectedServer,\n      getMoreOptions\n    );\n\n    return await executeOperation(this.cursorClient, getMoreOperation, this.timeoutContext);\n  }\n\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  private async cursorInit(): Promise<void> {\n    if (this.cursorOptions.timeoutMS != null) {\n      this.timeoutContext ??= new CursorTimeoutContext(\n        TimeoutContext.create({\n          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n          timeoutMS: this.cursorOptions.timeoutMS\n        }),\n        this\n      );\n    }\n    try {\n      const state = await this._initialize(this.cursorSession);\n      // Set omitMaxTimeMS to the value needed for subsequent getMore calls\n      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(undefined, error);\n      throw error;\n    }\n\n    if (this.isDead) {\n      await this.cleanup();\n    }\n\n    return;\n  }\n\n  /** @internal Attempt to obtain more documents */\n  private async fetchBatch(): Promise<void> {\n    if (this.isClosed) {\n      return;\n    }\n\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n      // Otherwise, run a getMore\n    }\n\n    // otherwise need to call getMore\n    const batchSize = this.cursorOptions.batchSize || 1000;\n\n    try {\n      const response = await this.getMore(batchSize);\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(undefined, error);\n      } catch (cleanupError) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        squashError(cleanupError);\n      }\n      throw error;\n    }\n\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n\n  /** @internal */\n  private async cleanup(timeoutMS?: number, error?: Error) {\n    this.abortListener?.[kDispose]();\n    this.isClosed = true;\n    const timeoutContextForKillCursors = (): CursorTimeoutContext | undefined => {\n      if (timeoutMS != null) {\n        this.timeoutContext?.clear();\n        return new CursorTimeoutContext(\n          TimeoutContext.create({\n            serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n            timeoutMS\n          }),\n          this\n        );\n      } else {\n        return this.timeoutContext?.refreshed();\n      }\n    };\n    try {\n      if (\n        !this.isKilled &&\n        this.cursorId &&\n        !this.cursorId.isZero() &&\n        this.cursorNamespace &&\n        this.selectedServer &&\n        !this.cursorSession.hasEnded\n      ) {\n        this.isKilled = true;\n        const cursorId = this.cursorId;\n        this.cursorId = Long.ZERO;\n\n        await executeOperation(\n          this.cursorClient,\n          new KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n            session: this.cursorSession\n          }),\n          timeoutContextForKillCursors()\n        );\n      }\n    } catch (error) {\n      squashError(error);\n    } finally {\n      try {\n        if (this.cursorSession?.owner === this) {\n          await this.cursorSession.endSession({ error });\n        }\n        if (!this.cursorSession?.inTransaction()) {\n          maybeClearPinnedConnection(this.cursorSession, { error });\n        }\n      } finally {\n        this.emitClose();\n      }\n    }\n  }\n\n  /** @internal */\n  private hasEmittedClose = false;\n  /** @internal */\n  private emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n\n  /** @internal */\n  private async transformDocument(document: NonNullable<TSchema>): Promise<NonNullable<TSchema>> {\n    if (this.transform == null) return document;\n\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR =\n          'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        squashError(closeError);\n      }\n      throw transformError;\n    }\n  }\n\n  /** @internal */\n  protected throwIfInitialized() {\n    if (this.initialized) throw new MongoCursorInUseError();\n  }\n}\n\nclass ReadableCursorStream extends Readable {\n  private _cursor: AbstractCursor;\n  private _readInProgress = false;\n\n  constructor(cursor: AbstractCursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._cursor = cursor;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override _read(size: number): void {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\n    this._cursor.close().then(\n      () => callback(error),\n      closeError => callback(closeError)\n    );\n  }\n\n  private _readNext() {\n    if (this._cursor.id === Long.ZERO) {\n      this.push(null);\n      return;\n    }\n\n    this._cursor.next().then(\n      result => {\n        if (result == null) {\n          this.push(null);\n        } else if (this.destroyed) {\n          this._cursor.close().then(undefined, squashError);\n        } else {\n          if (this.push(result)) {\n            return this._readNext();\n          }\n\n          this._readInProgress = false;\n        }\n      },\n      err => {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().then(undefined, squashError);\n          return this.push(null);\n        }\n\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n        if (err.message.match(/operation was interrupted/)) {\n          return this.push(null);\n        }\n\n        // NOTE: The two above checks on the message of the error will cause a null to be pushed\n        //       to the stream, thus closing the stream before the destroy call happens. This means\n        //       that either of those error messages on a change stream will not get a proper\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n        //       relies on that error event to be emitted to create its new cursor and thus was not\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n        //       See NODE-4475.\n        return this.destroy(err);\n      }\n    );\n  }\n}\n\nconfigureResourceManagement(AbstractCursor.prototype);\n\n/**\n * @internal\n * The cursor timeout context is a wrapper around a timeout context\n * that keeps track of the \"owner\" of the cursor.  For timeout contexts\n * instantiated inside a cursor, the owner will be the cursor.\n *\n * All timeout behavior is exactly the same as the wrapped timeout context's.\n */\nexport class CursorTimeoutContext extends TimeoutContext {\n  constructor(\n    public timeoutContext: TimeoutContext,\n    public owner: symbol | AbstractCursor\n  ) {\n    super();\n  }\n  override get serverSelectionTimeout(): Timeout | null {\n    return this.timeoutContext.serverSelectionTimeout;\n  }\n  override get connectionCheckoutTimeout(): Timeout | null {\n    return this.timeoutContext.connectionCheckoutTimeout;\n  }\n  override get clearServerSelectionTimeout(): boolean {\n    return this.timeoutContext.clearServerSelectionTimeout;\n  }\n  override get timeoutForSocketWrite(): Timeout | null {\n    return this.timeoutContext.timeoutForSocketWrite;\n  }\n  override get timeoutForSocketRead(): Timeout | null {\n    return this.timeoutContext.timeoutForSocketRead;\n  }\n  override csotEnabled(): this is CSOTTimeoutContext {\n    return this.timeoutContext.csotEnabled();\n  }\n  override refresh(): void {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.refresh();\n  }\n  override clear(): void {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.clear();\n  }\n  override get maxTimeMS(): number | null {\n    return this.timeoutContext.maxTimeMS;\n  }\n  get timeoutMS(): number | null {\n    return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;\n  }\n  override refreshed(): CursorTimeoutContext {\n    return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);\n  }\n  override addMaxTimeMSToCommand(command: Document, options: { omitMaxTimeMS?: boolean }): void {\n    this.timeoutContext.addMaxTimeMSToCommand(command, options);\n  }\n  override getSocketTimeoutMS(): number | undefined {\n    return this.timeoutContext.getSocketTimeoutMS();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}