{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;\nconst error_1 = require(\"../error\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass DropCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n  get commandName() {\n    return 'drop';\n  }\n  async execute(server, session, timeoutContext) {\n    var _db$client$s$options$, _options$encryptedFie;\n    const db = this.db;\n    const options = this.options;\n    const name = this.name;\n    const encryptedFieldsMap = (_db$client$s$options$ = db.client.s.options.autoEncryption) === null || _db$client$s$options$ === void 0 ? void 0 : _db$client$s$options$.encryptedFieldsMap;\n    let encryptedFields = (_options$encryptedFie = options.encryptedFields) !== null && _options$encryptedFie !== void 0 ? _options$encryptedFie : encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap[\"\".concat(db.databaseName, \".\").concat(name)];\n    if (!encryptedFields && encryptedFieldsMap) {\n      var _listCollectionsResul;\n      // If the MongoClient was configured with an encryptedFieldsMap,\n      // and no encryptedFields config was available in it or explicitly\n      // passed as an argument, the spec tells us to look one up using\n      // listCollections().\n      const listCollectionsResult = await db.listCollections({\n        name\n      }, {\n        nameOnly: false\n      }).toArray();\n      encryptedFields = listCollectionsResult === null || listCollectionsResult === void 0 || (_listCollectionsResul = listCollectionsResult[0]) === null || _listCollectionsResul === void 0 || (_listCollectionsResul = _listCollectionsResul.options) === null || _listCollectionsResul === void 0 ? void 0 : _listCollectionsResul.encryptedFields;\n    }\n    if (encryptedFields) {\n      const escCollection = encryptedFields.escCollection || \"enxcol_.\".concat(name, \".esc\");\n      const ecocCollection = encryptedFields.ecocCollection || \"enxcol_.\".concat(name, \".ecoc\");\n      for (const collectionName of [escCollection, ecocCollection]) {\n        // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n        const dropOp = new DropCollectionOperation(db, collectionName);\n        try {\n          await dropOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);\n        } catch (err) {\n          if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n            throw err;\n          }\n        }\n      }\n    }\n    return await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);\n  }\n  async executeWithoutEncryptedFieldsCheck(server, session, timeoutContext) {\n    await super.executeCommand(server, session, {\n      drop: this.name\n    }, timeoutContext);\n    return true;\n  }\n}\nexports.DropCollectionOperation = DropCollectionOperation;\n/** @internal */\nclass DropDatabaseOperation extends command_1.CommandOperation {\n  constructor(db, options) {\n    super(db, options);\n    this.options = options;\n  }\n  get commandName() {\n    return 'dropDatabase';\n  }\n  async execute(server, session, timeoutContext) {\n    await super.executeCommand(server, session, {\n      dropDatabase: 1\n    }, timeoutContext);\n    return true;\n  }\n}\nexports.DropDatabaseOperation = DropDatabaseOperation;\n(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"names":["error_1","require","command_1","operation_1","DropCollectionOperation","CommandOperation","constructor","db","name","options","arguments","length","undefined","commandName","execute","server","session","timeoutContext","_db$client$s$options$","_options$encryptedFie","encryptedFieldsMap","client","s","autoEncryption","encryptedFields","concat","databaseName","_listCollectionsResul","listCollectionsResult","listCollections","nameOnly","toArray","escCollection","ecocCollection","collectionName","dropOp","executeWithoutEncryptedFieldsCheck","err","MongoServerError","code","MONGODB_ERROR_CODES","NamespaceNotFound","executeCommand","drop","exports","DropDatabaseOperation","dropDatabase","defineAspects","Aspect","WRITE_OPERATION"],"sources":["/Users/glebch/workprojects/baumna/client/node_modules/mongodb/src/operations/drop.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Db } from '../db';\nimport { MONGODB_ERROR_CODES, MongoServerError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface DropCollectionOptions extends CommandOperationOptions {\n  /** @experimental */\n  encryptedFields?: Document;\n}\n\n/** @internal */\nexport class DropCollectionOperation extends CommandOperation<boolean> {\n  override options: DropCollectionOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options: DropCollectionOptions = {}) {\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  override get commandName() {\n    return 'drop' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<boolean> {\n    const db = this.db;\n    const options = this.options;\n    const name = this.name;\n\n    const encryptedFieldsMap = db.client.s.options.autoEncryption?.encryptedFieldsMap;\n    let encryptedFields: Document | undefined =\n      options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n    if (!encryptedFields && encryptedFieldsMap) {\n      // If the MongoClient was configured with an encryptedFieldsMap,\n      // and no encryptedFields config was available in it or explicitly\n      // passed as an argument, the spec tells us to look one up using\n      // listCollections().\n      const listCollectionsResult = await db\n        .listCollections({ name }, { nameOnly: false })\n        .toArray();\n      encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n    }\n\n    if (encryptedFields) {\n      const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n      const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n      for (const collectionName of [escCollection, ecocCollection]) {\n        // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n        const dropOp = new DropCollectionOperation(db, collectionName);\n        try {\n          await dropOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);\n        } catch (err) {\n          if (\n            !(err instanceof MongoServerError) ||\n            err.code !== MONGODB_ERROR_CODES.NamespaceNotFound\n          ) {\n            throw err;\n          }\n        }\n      }\n    }\n\n    return await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);\n  }\n\n  private async executeWithoutEncryptedFieldsCheck(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<boolean> {\n    await super.executeCommand(server, session, { drop: this.name }, timeoutContext);\n    return true;\n  }\n}\n\n/** @public */\nexport type DropDatabaseOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropDatabaseOperation extends CommandOperation<boolean> {\n  override options: DropDatabaseOptions;\n\n  constructor(db: Db, options: DropDatabaseOptions) {\n    super(db, options);\n    this.options = options;\n  }\n  override get commandName() {\n    return 'dropDatabase' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<boolean> {\n    await super.executeCommand(server, session, { dropDatabase: 1 }, timeoutContext);\n    return true;\n  }\n}\n\ndefineAspects(DropCollectionOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropDatabaseOperation, [Aspect.WRITE_OPERATION]);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}